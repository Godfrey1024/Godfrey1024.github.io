<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL分库分表</title>
      <link href="/posts/7417.html"/>
      <url>/posts/7417.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>互联网业务兴起之后，海量用户加上海量数据的特点，单个数据库服务器已经难以满足业务发展的需求，必须考虑数据库集群的方式来提升性能。</p><p>高性能数据库集群的特点：</p><ol><li><p>读写分离。</p></li><li><p>数据库分片。</p></li></ol><h2 id="读写分离架构"><a href="#读写分离架构" class="headerlink" title="读写分离架构"></a>读写分离架构</h2><p>读写分离的原理：就是将数据库的读写操作分散到不同的节点上。下面是其基本的架构图：</p><p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/202310190110627.png" alt="202310190110627.png"></p><p>读写分离的基本实现：</p><ul><li><p>主库负责处理事务性的增删改操作，从库负责处理查询操作，这样能够有效的避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善。</p></li><li><p>读写分离是根据 SQL 语义的分析，将读操作和写操作分别路由到主库和从库的。</p></li><li><p>通过一主多从的配置方式，可以将查询请求均匀的分散到多个数据副本，能够进一步的提升系统的处理能力。</p></li><li><p>使用多主多从的配置方式，不但能够提升系统的吞吐量，还能够提升系统的可用性（甚至任何一个数据库宕机或者磁盘损坏的情况下依然不影响系统的正常运行）。</p></li></ul><p>下图展示了根据业务需求，将用户表的写操作和读操作路由到不同的数据库的方案：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/202310190110027.png" alt="202310190110027.png" style="zoom:67%;" /><h2 id="数据库分片架构"><a href="#数据库分片架构" class="headerlink" title="数据库分片架构"></a>数据库分片架构</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>读写分离的问题：读写分离可以解决海量用户并发访问的压力，因为读写分离将并发的读操作和写操作分散到了不同的数据库中，从而分散了单台数据库并发读写操作的压力，但是并没有分散存储压力，为了满足业务数据存储的需求，就需要将存储分散到多台数据库服务器上。</p><p>数据分片：将存放在单一数据库中的数据分散的存放到多个数据库或表中，以达到提升性能瓶颈以及可用性的效果。数据分片的有效手段是对关系型数据库进行分库分表。数据分片的拆分方式又分为 垂直分片 和 水平分片。</p><h4 id="垂直分片之垂直分库"><a href="#垂直分片之垂直分库" class="headerlink" title="垂直分片之垂直分库"></a>垂直分片之垂直分库</h4><p>按照业务拆分的方式称为垂直分片，又称为纵向拆分，它的核心理念是专库专用。在拆分之前，一个数据库由多个数据表构成，每个表对应着不同的业务。而拆分之后，则是按照业务将表进行归类，分布到不同的数据库中，从而将压力分散至不同的数据库中。</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231020210443294.png" alt="image-20231020210443294" style="zoom:67%;" /><p>下图展示了根据业务需求，将用户表和订单表垂直分片到不同的数据库的方案：</p> <img src="https://qiniu.chengke.net/mysql/202310190110243.png" alt="img" style="zoom: 67%;" /><p>垂直拆分可以缓解数据量和访问量带来的问题，但是无法根治。如果垂直拆分之后，表中的数据量依然超过单节点所能承载的阈值，则需要水平分片来进一步处理。</p><blockquote><p>阿里巴巴 Java 开发手册：</p><p>【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。<br>说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p></blockquote><h4 id="垂直分片之垂直分表"><a href="#垂直分片之垂直分表" class="headerlink" title="垂直分片之垂直分表"></a>垂直分片之垂直分表</h4><p>垂直分表适合于将表中某些不常用的列，或者占用了大量空间的列拆分出去。</p><p>假设我们是一个婚恋网络，用户在筛选其他用户的时候，主要使用 age 和 sex 两个字段进行查询，而 nickname 和 description 两个字段主要用于展示，一般不会在业务查询中使用到。而 description 字段本身占用空间比较大，因为我们可以将 nickname 和 description 两个字段独立到另外一张包中，这样在查询 age 和 sex 的时候，就能带来一定的性能提升。</p><p>垂直分表引入的复杂性主要体现在表操作的数量的增加。比如，原来只要一次查询就可以获取 name、age、nickname、description ，现在需要两次查询：一次获取 name、age、sex，另外一次查询获取 nickname、description。并且新增的时候也可能需要维护两次。</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231020205908986.png" alt="image-20231020205908986" style="zoom: 67%;" /><blockquote><p>注意：水平分表适合表行数特别大的表，水平分表属于水平分片。</p></blockquote><h4 id="水平分片"><a href="#水平分片" class="headerlink" title="水平分片"></a>水平分片</h4><p>水平分片又称为横向拆分，相对于垂直分片，它不再将数据根据业务逻辑分类，而是通过某个字段（或某几个字段），根据某种规则将数据分散到多个库或表中，每个分片仅包含数据的一部分，比如：根据主键分片，偶数主键的记录放入 0 库（或表），奇数主键的记录放入 1 库（或表），如下图所示：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231020210057411.png" alt="image-20231020210057411" style="zoom: 67%;" /><blockquote><p>注意：单表进行切分后，是否将多个表分散在不同的数据库服务器中，可以根据实际切分的效果来确定。</p></blockquote><p>水平分表：单表切分为多表后，新的表即使在同一个数据库服务器中，也可能带来客观的性能提升；如果性能能够满足业务需要，可以不拆分到多台数据库服务器，毕竟业务分库会引入很多复杂性。</p><p>水平分库：如果单表拆分为多表后，单台服务器依然无法满足性能要求，那么就需要将多个表分散在不同的数据库服务器总。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>读写分离和数据分片具体的实现方式一般有两种：</p><p>① 程序代码封装。</p><p>② 中间件封装。</p><h3 id="程序代码封装"><a href="#程序代码封装" class="headerlink" title="程序代码封装"></a>程序代码封装</h3><p>程序代码封装指的是在代码中抽象一个 数据访问层（或中间层封装），实现读写操作分离和数据库服务器连接的管理。</p><p>其基本架构是：以读写分离为例</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231020210259318.png" alt="image-20231020210259318" style="zoom: 80%;" /><h3 id="中间件封装"><a href="#中间件封装" class="headerlink" title="中间件封装"></a>中间件封装</h3><p>中间件封装指的是 独立一套系统 出来，实现读写操作分离和数据库服务器连接的管理。对于业务服务器来说，访问中间件和访问数据库没有什么区别，在业务服务器看来，中间件就是一个数据库服务器。</p><p>其基本架构是：以读写分离为例</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231020210343563.png" alt="image-20231020210343563" style="zoom:67%;" /><h3 id="常见解决方案"><a href="#常见解决方案" class="headerlink" title="常见解决方案"></a>常见解决方案</h3><p>Shardingsphere：程序级别和中间件级别。</p><p>MyCat：中间件级别。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> ShardingSphere </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP理论</title>
      <link href="/posts/44851.html"/>
      <url>/posts/44851.html</url>
      
        <content type="html"><![CDATA[<h2 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>CAP 理论（CAP theorem）又被称作布鲁尔理论（Brewer’s theorem），是加州大学伯克利分校的计算机科学家埃里克·布鲁尔（Eric Brewer）在 2000 年的 ACM PODC 上提出的一个猜想。对于设计分布式系统的架构师来说，CAP 是必须掌握的理论。</p><p>在一个分布式系统中，当涉及到读写操作的时候，只能保证一致性（Consistency）、可用性（Availability）、分区容错性（Partition Tolerance）三者中的两个，另一个必须被牺牲。</p><p>C 就是一致性（Consistency ）：对某个指定的客户端来说，读操作保证能够返回最新的写操作结果。</p><p>A 就是可用性（Availability）：非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应），有可能不是最新的数据，而是旧的数据。</p><p>P 就是分区容错性（Partition Tolerance）：当出现网络分区后，系统能够继续 “履行职责”。</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/202310190110812.jpeg" alt="202310190110812.jpeg" style="zoom: 80%;" /><h3 id="CAP-的理解"><a href="#CAP-的理解" class="headerlink" title="CAP 的理解"></a>CAP 的理解</h3><p>CAP 是描述性理论，不是工程理论，它舍弃了很多现实世界中的问题，比如：网络波动、丢包、节点处理速度不一致等问题。</p><p>在一个分布式系统中，节点组成的网络本来应该是互相连通的，但是因为一些故障（网络波动、丢包、节点处理速度不一样等），使得有些节点之间不能互通，那么整个网络就分成了几块区域。数据就散布在了这些不连通的区域中，这就是分区。</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231020210507215.png" alt="image-20231020210507215" style="zoom: 80%;" /><p>当一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了，这个时候分区是无法容忍的。</p><p>提高分区容忍性的办法就是将一个数据项复制到多个节点上，那么出现分区之后，这一数据项就有可能分布到各个区里面，那么容忍性就提高了；换言之，任意客户端（如：Java 等）连接到各个节点的服务器上都有数据了，虽然可能是旧数据，就像上图中的 Redis 一样。</p><p>但是，要将数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据有可能不一致。如果要一致，每次写操作都需要等待全部节点成功（强一致性，在现在的分布式系统中，想保证实时强一致性几乎不太可能，追求的是最终一致性），其中最差的方案（性能最差）就是写的时候加锁，写完之后释放锁；但是在各个节点在写的时候，如果有客户端又发送了写请求，就会出现可用性问题。那么什么是可用性问题？如果一个客户端在合理的时间内和服务器进行通信，一直死活连不上，或者一直报超时，甚至是 ERROR，客户端就会觉得服务器可能已经宕机。</p><p>总体来说，数据存在的节点越多，分区容忍性就越高，但是复制更新的数据就越多，一致性就难以保证。为了保证一致性，更新所有节点所需要花费的时间就越长，可用性就会降低。</p><blockquote><p>注意：</p><p>C（一致性）就是客户端是否能拿到最新数据，不是所谓的强一致性。<br>A（可用性）就是允许客户端拿不到最近的数据，但是可以是旧的数据；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Github托管项目</title>
      <link href="/posts/60316.html"/>
      <url>/posts/60316.html</url>
      
        <content type="html"><![CDATA[<h2 id="GitHub托管本地项目"><a href="#GitHub托管本地项目" class="headerlink" title="GitHub托管本地项目"></a>GitHub托管本地项目</h2><p>Git连接远程仓库时支持两种协议，SSH和HTTPS。</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231021161413637.png" alt="image-20231021161413637" style="zoom:67%;" /><h3 id="SSH连接"><a href="#SSH连接" class="headerlink" title="SSH连接"></a>SSH连接</h3><h4 id="生成SSH秘钥对"><a href="#生成SSH秘钥对" class="headerlink" title="生成SSH秘钥对"></a>生成SSH秘钥对</h4><p>在本地打开GitBash窗口，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>   <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231021161937546.png" alt="image-20231021161937546" style="zoom: 80%;" /><p>​生成成功的话，在C盘用户目录下会有一个名为.ssh的目录，里面是ssh的公钥和私钥文件。</p><p>​<img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231021162238891.png" alt="image-20231021162238891"></p><h4 id="配置公钥到Github账户"><a href="#配置公钥到Github账户" class="headerlink" title="配置公钥到Github账户"></a>配置公钥到Github账户</h4><p>第一步：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231021162724854.png" alt="image-20231021162724854" style="zoom: 50%;" /><p>第二步：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231021163020266.png" alt="image-20231021163020266" style="zoom:67%;" /><h4 id="配置本地项目"><a href="#配置本地项目" class="headerlink" title="配置本地项目"></a>配置本地项目</h4><p>第一步,查看当前git的远程仓库版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br></pre></td></tr></table></figure><p>此时若什么都没有显示说明，git无远程仓库。</p><p>第二步，添加ssh协议的远程仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add 名称 远程仓库ssh地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">名称任意，远程仓库我们一般命名为<span class="string">&quot;origin&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">远程仓库ssh地址，我们直接从Github粘贴过来，防止写错</span></span><br></pre></td></tr></table></figure> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231021163714702.png" alt="image-20231021163714702" style="zoom:67%;" /><p>再次查看，此时本地项目已经和远程仓库关联起来了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin  git@github.com:Godfrey1024/Godfrey1024.github.io.git</span><br><span class="line">origin  git@github.com:Godfrey1024/Godfrey1024.github.io.git</span><br></pre></td></tr></table></figure><p>ssh连接的好处是每次提交代码时，不需要重复来回输入用户名和密码。</p><p>有的时候拉取合并代码的时候，会报出如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull origin master</span></span><br><span class="line">ssh: connect to host github.com port 22: Connection refused</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure><p>大概率是由于当前网络的原因，当前网络禁止SSH协议的22端口，尤其是公司企业网络。那么只能换一种连接进行合并本地仓库了。</p><h3 id="HTTPS连接"><a href="#HTTPS连接" class="headerlink" title="HTTPS连接"></a>HTTPS连接</h3><p>依然是先查看当前远程仓库使用的那种协议连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin  git@github.com:Godfrey1024/Godfrey1024.github.io.git</span><br><span class="line">origin  git@github.com:Godfrey1024/Godfrey1024.github.io.git</span><br></pre></td></tr></table></figure><p>移除掉远程仓库的配置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote <span class="built_in">rm</span> origin</span></span><br></pre></td></tr></table></figure><p>重新添加新的远程仓库，以https的形式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/Godfrey1024/Godfrey1024.github.io.git</span><br></pre></td></tr></table></figure> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231023124842105.png" alt="image-20231023124842105" style="zoom:67%;" /><p>完成以上切换操作，其实问题就已经解决了。</p><p>再次尝试pull代码，可以看到已经成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull origin master</span></span><br><span class="line">remote: Counting objects: 21, done.</span><br><span class="line">remote: Compressing objects: 100% (8/8), done.</span><br><span class="line">Unpacking objects: 100% (21/21), done.</span><br><span class="line">remote: Total 21 (delta 5), reused 21 (delta 5), pack-reused 0</span><br><span class="line">From https://github.com/Godfrey1024/Godfrey1024.github.io</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line"> * [new branch]      master     -&gt; origin/master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hasCode生成逻辑</title>
      <link href="/posts/38529.html"/>
      <url>/posts/38529.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>先抛出一个问题：Object类中hashCode方法的返回值是对象的内存地址值吗？</p><p>hashCode方法是一个本地方法，Object类中是这样声明的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h2 id="简单的打印"><a href="#简单的打印" class="headerlink" title="简单的打印"></a>简单的打印</h2><p>先看一个最简单的打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">System.out.println(o);</span><br></pre></td></tr></table></figure><p>会输出该类的全限定类名和一串字符串：<code>java.lang.Object@6659c656</code></p><p><code>@</code>符号后面的是什么？是hashcode值还是对象的内存地址？还是其他的什么值？</p><p>其实<code>@</code>后面的只是对象的hashcode值，以16进制展示的hashcode值而已，来验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">hashcode</span> <span class="operator">=</span> o.hashCode();</span><br><span class="line"><span class="comment">// toString</span></span><br><span class="line">System.out.println(o);</span><br><span class="line"><span class="comment">// hashcode 十六进制</span></span><br><span class="line">System.out.println(Integer.toHexString(hashcode));</span><br><span class="line"><span class="comment">// hashcode</span></span><br><span class="line">System.out.println(hashcode);</span><br><span class="line"><span class="comment">// 下面这个方法，也是获取对象的 hashcode；不过和 Object.hashcode 不同的是，该方法会无视重写的hashcode</span></span><br><span class="line">System.out.println(System.identityHashCode(o));</span><br><span class="line"></span><br><span class="line">#######输出结果###########</span><br><span class="line">java.lang.Object@6659c656</span><br><span class="line">6659c656</span><br><span class="line"><span class="number">1717159510</span></span><br><span class="line"><span class="number">1717159510</span></span><br></pre></td></tr></table></figure><p>打印输出一个对象时，默认调用该对象的toString方法，从Object类中的toString方法的实现也可以确定@<code>@</code>后面的只是对象的hashcode值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那对象的hashcode值到底是怎么生成的呢？真的就是内存地址吗？</p><p>下面我们一步步深入JDK源码，看一下hashCode方法是怎么实现的，再回答上面的问题。</p><h2 id="hashCode实现"><a href="#hashCode实现" class="headerlink" title="hashCode实现"></a>hashCode实现</h2><p><strong>基于 Java8 HotSpot</strong></p><p>JVM里hashCode方法的实现并没有那么简单，它提供了好几种策略，每种策略的生成结果都不同。</p><p>来看一下OpenJDK源码里，实现hashCode方法的核心方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">intptr_t</span> <span class="title">get_next_hash</span><span class="params">(Thread * Self, oop obj)</span> </span>&#123;</span><br><span class="line">  <span class="type">intptr_t</span> value = <span class="number">0</span> ;</span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// This form uses an unguarded global Park-Miller RNG,</span></span><br><span class="line">     <span class="comment">// so it&#x27;s possible for two threads to race and generate the same RNG.</span></span><br><span class="line">     <span class="comment">// On MP system we&#x27;ll have lots of RW access to a global, so the</span></span><br><span class="line">     <span class="comment">// mechanism induces lots of coherency traffic.</span></span><br><span class="line">     value = os::<span class="built_in">random</span>() ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">// This variation has the property of being stable (idempotent)</span></span><br><span class="line">     <span class="comment">// between STW operations.  This can be useful in some of the 1-0</span></span><br><span class="line">     <span class="comment">// synchronization schemes.</span></span><br><span class="line">     <span class="type">intptr_t</span> addrBits = <span class="built_in">intptr_t</span>(obj) &gt;&gt; <span class="number">3</span> ;</span><br><span class="line">     value = addrBits ^ (addrBits &gt;&gt; <span class="number">5</span>) ^ GVars.stwRandom ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">2</span>) &#123;</span><br><span class="line">     value = <span class="number">1</span> ;            <span class="comment">// for sensitivity testing</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">3</span>) &#123;</span><br><span class="line">     value = ++GVars.hcSequence ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">4</span>) &#123;</span><br><span class="line">     value = <span class="built_in">intptr_t</span>(obj) ;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Marsaglia&#x27;s xor-shift scheme with thread-specific state</span></span><br><span class="line">     <span class="comment">// This is probably the best overall implementation -- we&#x27;ll</span></span><br><span class="line">     <span class="comment">// likely make this the default in future releases.</span></span><br><span class="line">     <span class="type">unsigned</span> t = Self-&gt;_hashStateX ;</span><br><span class="line">     t ^= (t &lt;&lt; <span class="number">11</span>) ;</span><br><span class="line">     Self-&gt;_hashStateX = Self-&gt;_hashStateY ;</span><br><span class="line">     Self-&gt;_hashStateY = Self-&gt;_hashStateZ ;</span><br><span class="line">     Self-&gt;_hashStateZ = Self-&gt;_hashStateW ;</span><br><span class="line">     <span class="type">unsigned</span> v = Self-&gt;_hashStateW ;</span><br><span class="line">     v = (v ^ (v &gt;&gt; <span class="number">19</span>)) ^ (t ^ (t &gt;&gt; <span class="number">8</span>)) ;</span><br><span class="line">     Self-&gt;_hashStateW = v ;</span><br><span class="line">     value = v ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  value &amp;= markOopDesc::hash_mask;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="number">0</span>) value = <span class="number">0xBAD</span> ;</span><br><span class="line">  <span class="built_in">assert</span> (value != markOopDesc::no_hash, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">TEVENT</span> (hashCode: GENERATE) ;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码里可以发现，生成策略是由一个 <code>hashCode</code> 的全局变量控制的，默认为5；而这个变量的定义在另一个头文件里：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">product</span>(intx, hashCode, <span class="number">5</span>,<span class="string">&quot;(Unstable) select hashCode generation algorithm&quot;</span> )</span><br></pre></td></tr></table></figure><p>源码里也说明了：”(Unstable) select hashCode generation algorithm,（非稳定）选择 hashCode 生成的算法”，而且这里的定义，是可以由 jvm 启动参数来控制的，先来确认下默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version | grep hashCode</span><br><span class="line"></span><br><span class="line">intx hashCode = 5 &#123;product&#125;</span><br><span class="line">openjdk version &quot;1.8.0_282&quot;</span><br><span class="line">OpenJDK Runtime Environment (AdoptOpenJDK)(build 1.8.0_282-b08)</span><br><span class="line">OpenJDK 64-Bit Server VM (AdoptOpenJDK)(build 25.282-b08, mixed mode)</span><br></pre></td></tr></table></figure><p>所以我们可以通过 jvm 的启动参数来配置不同的hashcode生成算法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:hashCode=N</span><br></pre></td></tr></table></figure><h3 id="第0种算法"><a href="#第0种算法" class="headerlink" title="第0种算法"></a>第0种算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hashCode == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// This form uses an unguarded global Park-Miller RNG,</span></span><br><span class="line">     <span class="comment">// so it&#x27;s possible for two threads to race and generate the same RNG.</span></span><br><span class="line">     <span class="comment">// On MP system we&#x27;ll have lots of RW access to a global, so the</span></span><br><span class="line">     <span class="comment">// mechanism induces lots of coherency traffic.</span></span><br><span class="line">     value = os::<span class="built_in">random</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这种生成算法，使用的一种 <code>Park-Miller RNG</code> 的随机数生成策略。不过需要注意的是, 这个随机算法在高并发的时候会出现自旋等待的情况。</p><h3 id="第1种算法"><a href="#第1种算法" class="headerlink" title="第1种算法"></a>第1种算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hashCode == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// This variation has the property of being stable (idempotent)</span></span><br><span class="line">    <span class="comment">// between STW operations.  This can be useful in some of the 1-0</span></span><br><span class="line">    <span class="comment">// synchronization schemes.</span></span><br><span class="line">    <span class="type">intptr_t</span> addrBits = <span class="built_in">intptr_t</span>(obj) &gt;&gt; <span class="number">3</span> ;</span><br><span class="line">    value = addrBits ^ (addrBits &gt;&gt; <span class="number">5</span>) ^ GVars.stwRandom ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法，真的是对象的内存地址了，直接获取对象的 <code>intptr_t 类型指针</code>。</p><h3 id="第2种算法"><a href="#第2种算法" class="headerlink" title="第2种算法"></a>第2种算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hashCode == <span class="number">2</span>) &#123;</span><br><span class="line">    value = <span class="number">1</span> ;         <span class="comment">// for sensitivity testing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就不用解释了……<code>固定返回 1</code>，应该是用于内部的测试场景。</p><p>有兴趣的同学，可以试试-XX:hashCode&#x3D;2来开启这个算法，看看 hashCode 结果是不是都变成 1 了。</p><h3 id="第3种算法"><a href="#第3种算法" class="headerlink" title="第3种算法"></a>第3种算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hashCode == <span class="number">3</span>) &#123;</span><br><span class="line">    value = ++GVars.hcSequence ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法也很简单，自增嘛，所有对象的 hashCode 都使用这一个<code>自增变量</code>。来试试效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"></span><br><span class="line">#####输出结果#######</span><br><span class="line">java.lang.Object@<span class="number">144</span></span><br><span class="line">java.lang.Object@<span class="number">145</span></span><br><span class="line">java.lang.Object@<span class="number">146</span></span><br><span class="line">java.lang.Object@<span class="number">147</span></span><br><span class="line">java.lang.Object@<span class="number">148</span></span><br><span class="line">java.lang.Object@<span class="number">149</span></span><br></pre></td></tr></table></figure><p>果然是自增的。</p><h3 id="第4种算法"><a href="#第4种算法" class="headerlink" title="第4种算法"></a>第4种算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hashCode == <span class="number">4</span>) &#123;</span><br><span class="line">    value = intptr_t(obj) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和第1种算法其实区别不大，都是返回<code>对象地址</code>，只是第1种算法是一个变体。</p><h3 id="第5种算法"><a href="#第5种算法" class="headerlink" title="第5种算法"></a>第5种算法</h3><p>最后一种，<strong>也是默认的生成算法</strong>，hashCode配置不等于 0&#x2F;1&#x2F;2&#x2F;3&#x2F;4 时使用该算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Marsaglia&#x27;s xor-shift scheme with thread-specific state</span></span><br><span class="line">     <span class="comment">// This is probably the best overall implementation -- we&#x27;ll</span></span><br><span class="line">     <span class="comment">// likely make this the default in future releases.</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="variable">t</span> <span class="operator">=</span> Self-&gt;_hashStateX ;</span><br><span class="line">     t ^= (t &lt;&lt; <span class="number">11</span>) ;</span><br><span class="line">     Self-&gt;_hashStateX = Self-&gt;_hashStateY ;</span><br><span class="line">     Self-&gt;_hashStateY = Self-&gt;_hashStateZ ;</span><br><span class="line">     Self-&gt;_hashStateZ = Self-&gt;_hashStateW ;</span><br><span class="line">     <span class="type">unsigned</span> <span class="variable">v</span> <span class="operator">=</span> Self-&gt;_hashStateW ;</span><br><span class="line">     v = (v ^ (v &gt;&gt; <span class="number">19</span>)) ^ (t ^ (t &gt;&gt; <span class="number">8</span>)) ;</span><br><span class="line">     Self-&gt;_hashStateW = v ;</span><br><span class="line">     value = v ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里是通过当前状态值进行异或运算得到的一个hashcode值，相比前面的自增算法和随机算法来说效率更高，但重复率应该也会相对增高，不过 hashcode值重复又有什么关系呢……</p><p>本来jvm就不保证这个值一定不重复，像HashMap里的链地址法就是解决hash冲突用的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的介绍，我们知道默认情况下，对象的hashcode的生成算法是第5种，所以默认请求情况下hashcode值并不是对象的内存地址值。</p><p>注意：hashcode可以是内存地址，也可以不是内存地址，甚至可以是常数1或者自增数。想用什么算法，它都可以！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8新特性-Lamda表达式</title>
      <link href="/posts/44073.html"/>
      <url>/posts/44073.html</url>
      
        <content type="html"><![CDATA[<p>在 Java8 之前，当实现只有一个方法的接口，我们通常是通过使用匿名内部类的方式来重写接口的方法，以 Comparator 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>Java8 中引入了 Lambda 表达式，提供了更加简洁的语法：<code>() -&gt; &#123;&#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">Collections.sort(list, (Integer o1, Integer o2) -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>从 Java8 开始编译器可以从接口的方法签名中自动推导出参数类型，因此可以省略掉类型的声明.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">Collections.sort(list, (o1, o2) -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>当方法体只有一行代码时，可以省略掉 {} 和 return 关键字以及代码行结束的分号“;”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">Collections.sort(list, (o1, o2) -&gt; o1.compareTo(o2));</span><br><span class="line">System.out.println(list); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>对于只有一个抽象方法的接口，都可以使用 Lambda 表达式。为了确保接口符合要求，可以使用 @FunctionalInterface 注解标注接口，被 @FunctionalInterface 注解标注的接口（称为函数式接口），只允许存在一个抽象方法，没有或多于一个抽象方法，编译都将无法通过。由于默认的方法不是抽象的，因此，函数式接口依然可以存在一个或多个默认方法。其中，每个 Lambda 表达式都将匹配函数式接口的这个抽象方法，Lambda 表达式的类型也由该接口类型决定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Operation</span>&lt;I, O&gt; &#123;</span><br><span class="line">O <span class="title function_">calculate</span><span class="params">(I input)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对函数式接口使用 Lambda 表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Operation&lt;Integer, Integer&gt; square = (i) -&gt; i * i;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> square.calculate(<span class="number">3</span>);</span><br><span class="line">System.out.println(result);<span class="comment">// 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK新特性 </tag>
            
            <tag> JDK8 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8新特性-接口默认方法</title>
      <link href="/posts/64503.html"/>
      <url>/posts/64503.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>在JDK8版本中，接口也可以为方法提供默认的实现，即接口也可以有自己的实现方法，具体的做法是使用关键字default即可为接口声明一个默认的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Predators</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;eat meat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何具体类在实现接口时，接口的默认方法不是必须实现的，非默认方法则必须实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Predators</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;wang....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口使用方面与平常无异，很自然。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">dog.doSomething();<span class="comment">// wang....</span></span><br><span class="line">dog.eat();<span class="comment">// eat meat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>关于多重继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Herbivore</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;eat fruit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下这段代码将无法通过编译。因 Predators 和 Herbivore 两个接口使用了同样签名的默认方法（eat），那么，在 Person 类中就无法确定最终使用哪个接口的默认实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Predators</span>, Herbivore &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;duang....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决冲突，你必须要通过手动重写的方式来修复。若想引用 Herbivore 接口中的 eat 方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Predators</span>, Herbivore &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">Herbivore.<span class="built_in">super</span>.eat();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;duang....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方面与平常无异，很自然。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person.doSomething();<span class="comment">// duang....</span></span><br><span class="line">person.eat();<span class="comment">// eat fruit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK新特性 </tag>
            
            <tag> JDK8 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>体会面向接口编程</title>
      <link href="/posts/42023.html"/>
      <url>/posts/42023.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>面向过程编程（ <code>ProcedureOriented</code>、简称 <code>PO</code>）</strong> 和 <strong>面向对象编程（ <code>ObjectOriented</code>、简称 <code>OO</code>）</strong> 我们一定听过，然而实际企业级开发里受用更多的一种编程思想那就是：<strong>面向接口编程（ <code>Interface-Oriented</code>）</strong>。</p><p>接口这个概念我们一定不陌生，实际生活中最常见的例子就是：插座。</p><p>我们只需要事先定义好插座的<strong>接口标准</strong>，各大插座厂商只要按这个接口标准生产，管你什么牌子、内部什么电路结构，这些均和用户无关，用户拿来就可以用；而且即使插座坏了，只要换一个符合接口标准的新插座，一切照样工作。</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231025082957760.png" alt="image-20231025082957760" style="zoom: 50%;" /><p>同理，实际代码设计也是这样。</p><p>我们在设计一个软件的代码架构时，我们都希望<strong>事先约定</strong>好各个功能的<strong>接口</strong>（即：约定好接口签名和方法），实际开发时我们只需要实现这个接口就能完成具体的功能。后续即使项目变化、功能升级，程序员只需要按照接口约定重新实现一下，就可以达到系统升级和扩展的目的。</p><p>正好，Java中天生就有 <code>interface</code>这个语法，这简直是为面向接口编程而生的！</p><p>所以接下来落实到代码上，举个通俗一点的例子，实际业务代码虽然比这个复杂，但原理是一模一样的。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>假设我有两辆“豪车”，一辆是五菱宏光，一辆是飞度，并且还专门聘请了一位驾驶员来帮助驾驶。那么我们需要定义三个类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WuLing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;驾驶五菱宏光汽车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;驾驶飞度汽车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 驾驶五菱宏光的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span> <span class="params">(Wuling wuling)</span> &#123;</span><br><span class="line">        wuling.drive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 驾驶飞度的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span> <span class="params">(Fit fit)</span> &#123;</span><br><span class="line">        fit.drive();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于测试功能的main方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化两辆新车</span></span><br><span class="line">        <span class="type">WuLing</span> <span class="variable">wuLing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WuLing</span>();</span><br><span class="line">        <span class="type">Fit</span> <span class="variable">fit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fit</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实例化驾驶员</span></span><br><span class="line">        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>();</span><br><span class="line">        <span class="comment">// 帮我开五菱宏光</span></span><br><span class="line">        driver.drive(wuLing);</span><br><span class="line">        <span class="comment">// 帮我开飞度</span></span><br><span class="line">        driver.drive(fit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果后面我发达了，又豪气地买了一辆新款奥拓（Alto）！可是现有的驾驶员类<code>Driver</code>的两个<code>drive()</code>方法里都开不了这辆新买的奥拓该怎么办呢？</p><h2 id="灵活解耦"><a href="#灵活解耦" class="headerlink" title="灵活解耦"></a>灵活解耦</h2><p>这时候，我想应该没有谁会专门再去往<code>Driver</code>类中添加一个新的<code>drive()</code>方法来达到目的吧？毕竟谁也不知道以后他还会不会买新车！</p><p>这时候如果我希望我聘请的这位驾驶员对于所有车型都能驾驭，该怎么办呢？</p><p>很容易想到，我们应该<strong>做一层抽象</strong>。毕竟不管是奥拓还是奥迪，它们都是汽车，因此我们<strong>定义一个父类</strong>叫做汽车类 <code>Car</code>，里面只声明一个通用的 <code>drive()</code>方法，具体怎么开先不用管：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象的汽车类Car，代表所有汽车</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Car</span>&#123;  </span><br><span class="line"><span class="comment">// 通用的汽车驾驶方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，只要我新买的奥拓符合<code>Car</code>定义的驾驶标准即可被我的驾驶员驾驶，所以只需要新的奥拓来继承一下 <code>Car</code>类即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alto</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;驾驶奥拓汽车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，只需要我的驾驶员具备通用汽车<code>Car</code>的驾驶能力，那驾驶所有的汽车都不是问题，因此<code>Drvier</code>类的<code>drive()</code>方法只要传入的参数是<strong>父类</strong>，那就具备了通用性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(Car car)</span> &#123;  <span class="comment">// 方法参数使用父类来替代</span></span><br><span class="line">        car.drive();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mian</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Alto</span> <span class="variable">alto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Alto</span>();</span><br><span class="line">        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>();</span><br><span class="line">        driver.drive(alto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再后来，我不想坐车了，想买一头马（Horse）让司机骑着带他出行！</p><p>很明显，原先适用于汽车的<code>drive()</code>方法肯定是不适合骑马的！但我们希望聘请的这位驾驶员既会开汽车，又会骑马怎么办呢？</p><p>我们干脆直接定义一个叫做交通工具（ <code>TrafficTools</code>）的通用接口吧！里面包含一个通用的交通工具使用方法，管你是驾驶汽车，还是骑驴骑马，具体技能怎么实现先不管：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的交通工具接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TrafficTool</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>;  <span class="comment">// 通用的交通工具的使用方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个<strong>接口约定</strong>，接下来就好办了。我们让所有的<code>Car</code>、或者驴、马等，都来实现这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">TrafficTool</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WuLing</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;驾驶五菱宏光&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fit</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;驾驶飞度&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alto</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;驾驶奥拓&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Horse</span> <span class="keyword">implements</span> <span class="title class_">TrafficTool</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;骑马&quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候只要我们的驾驶员师傅也<strong>面向接口编程</strong>，就没有任何问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line">    <span class="comment">// 方法参数面向接口编程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(TrafficTool trafficTool)</span> &#123;</span><br><span class="line">        trafficTool.drive();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(Strings[] args)</span> &#123;</span><br><span class="line">        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>();</span><br><span class="line">        driver.drive(<span class="keyword">new</span> <span class="title class_">WuLing</span>());  <span class="comment">// 驾驶五菱宏光</span></span><br><span class="line">        driver.drive(<span class="keyword">new</span> <span class="title class_">Fit</span>());  <span class="comment">// 驾驶飞度</span></span><br><span class="line">        driver.drive(<span class="keyword">new</span> <span class="title class_">Alto</span>());  <span class="comment">// 驾驶奥拓</span></span><br><span class="line">        driver.drive(<span class="keyword">new</span> <span class="title class_">Horse</span>());  <span class="comment">// 骑马</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，代码完全解耦了！这就是接口带来的便利。</p><h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2><p>面向接口编程的优点远不止上面这种代码解耦的场景，在实际企业开发里，利用接口思想<strong>对已有代码进行灵活扩展</strong>也特别常见。</p><p>再举一个例子：假设我有一个非常豪气的朋友，他们家出行可不坐车，全靠私人飞机出行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的飞机飞行接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Plane</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 朋友的专用机长，受过专业训练（即：实现了通用飞行接口）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlaneDriver</span> <span class="keyword">implements</span> <span class="title class_">Plane</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出门旅行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Travel</span> &#123;</span><br><span class="line">    <span class="comment">// 此处方法参数也是面向接口编程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">(Plane plane)</span> &#123;</span><br><span class="line">        plane.fly();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Travel</span> <span class="variable">travel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Travel</span>();  <span class="comment">// 开启一段旅行</span></span><br><span class="line">        <span class="type">PlaneDriver</span> <span class="variable">planeDriver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlaneDriver</span>();  <span class="comment">// 聘请一个机长</span></span><br><span class="line">        travel.fly(planeDriver);  <span class="comment">// 由机长开飞机带着全家去旅行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是突然有一天，他们家聘请的机长跳槽了，这时候我朋友他们一家就无法出行了，毕竟他们不会驾驶飞机。</p><p>于是他跑来问我借司机，想让我的驾驶员来帮他驾驶飞机出去旅行。</p><p>我一看，由于他们的代码面向的是接口，我就肯定地答应了他！</p><p>这时候对我这边的扩展来说就非常容易了，我只需要安排我的驾驶员去培训一下飞行技能就OK了（实现一个方法就行）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让我的驾驶员去培训一下飞行技能（即：去实现通用飞行接口）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">implements</span> <span class="title class_">Plane</span> &#123;</span><br><span class="line">    <span class="comment">// 方法参数面向接口编程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(TrafficTool trafficTool)</span> &#123;</span><br><span class="line">        trafficTool.drive();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现了fly()方法，这下我的驾驶员也具备操控飞机的能力了！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通驾驶员操控飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我的驾驶员 <code>Driver</code>类就可以直接服务于他们一家的出行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Travel</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">(Plane plane)</span> &#123;</span><br><span class="line">        plane.fly();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Travel</span> <span class="variable">travel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Travel</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 专业飞行员操控飞机</span></span><br><span class="line">        <span class="type">PlaneDriver</span> <span class="variable">planeDrvier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlaneDriver</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 普通驾驶员操控飞机</span></span><br><span class="line">        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>();</span><br><span class="line">        travle.fly(driver);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到没，这一改造过程中，我们只增加了代码，却并没有修改任何已有代码，就完成了代码扩展的任务，非常符合<strong>开闭原则</strong>！</p><h2 id="实际项目"><a href="#实际项目" class="headerlink" title="实际项目"></a>实际项目</h2><p>实际开发中，我们就暂且不说诸如<code>Spring</code>这种框架内部会大量使用接口，并对外提供使用，就连我们自己平时写业务代码，我们也习惯于在<code>Service</code>层使用接口来进行一层隔离：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231025140612057.png" alt="image-20231025140612057" style="zoom: 80%;" /><p>这种接口定义和具体实现逻辑的分开，非常有利于后续扩展和维护。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面向接口编程开发，对代码架构的解耦和扩展确实很有好处，这种编码思想也值得平时开发结合实践反复理解和回味。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>熟悉的陌生类-Object</title>
      <link href="/posts/45969.html"/>
      <url>/posts/45969.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Object是java所有类的基类，是整个类继承结构的顶端，也是最抽象的一个类</strong>。大家天天都在使用<code>toString()、equals()、hashCode()、wait()、notify()、getClass()</code>等方法，或许都没有意识到是<code>Object</code>类的方法，也没有去看<code>Object</code>类中还有哪些方法以及思考为什么这些方法要放到 <code>Object</code>中。本篇就每个方法具体功能、重写规则以及自己的一些理解。</p><h2 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h2><p><code>Object</code>中含有：<code>registerNatives()、getClass()、hashCode()、equals()、clone()、toString()、notify()、notifyAll()、wait(long)、wait(long,int)、wait()、finalize()</code> 共<strong>十二个方法</strong>。这个顺序是按照<code>Object</code>类中定义方法的顺序列举的，下面我也会按照这个顺序依次进行讲解。</p><h3 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives()"></a>registerNatives()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从名字上理解，这个方法是注册<code>native</code>方法</strong>（本地方法，由<code>JVM</code>实现，底层是<code>C/C++</code>实现的）**向谁注册呢？当然是向<code>JVM</code>**，当有程序调用到<code>native</code>方法时， <code>JVM</code>才好去找到这些底层的方法进行调用。</p><blockquote><p><code>Object</code>中的<code>native</code>方法，以及使用<code>registerNatives()</code>向<code>JVM</code>进行注册相关的知识属于<code>JNI</code>的范畴，有兴趣的可自行查阅。</p></blockquote><p><strong>为什么要使用静态方法，还要放到静态块中呢？</strong></p><p>我们知道在类初始化的时候，会依次将从父类到本类的类变量及类初始化块中的类变量及方法按照定义顺序放到<code>&lt;clinit&gt;</code>方法中，这样可以保证父类的类变量及方法的初始化一定先于子类。所以当子类调用相应<code>native</code>方法，比如计算<code>hashCode</code>时，一定可以保证能够调用到<code>JVM</code>的 <code>native</code>方法。</p><h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure><p>这是一个<code>public</code>的方法，我们可以直接通过对象调用。</p><p>类加载的第一阶段类的加载就是将<code>.class</code>文件加载到内存，并生成一个<code>java.lang.Class</code>对象的过程。 <code>getClass()</code>方法就是获取这个对象，这是当前类的对象在运行时类的所有信息的集合。这个方法是反射三种方式之一。</p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>这是一个<code>public</code>的方法，所以子类可以重写它。这个方法返回当前对象的<code>hashCode</code>值，这个值是一个整数范围内的 <code>（-2^31~2^31-1）</code>数字。</p><p>对于 <code>hashCode</code>有以下几点约束:</p><ol><li>在Java应用程序执行期间，在对同一对象多次调用<code>hashCode</code> 方法时，必须一致地返回相同的整数，前提是将对象进行<code>equals</code>比较时所用的信息没有被修改；</li><li>如果两个对象<code>x.equals(y)</code>方法返回<code>true</code>，则 <code>x</code>、<code>y</code>这两个对象的<code>hashCode</code>必须相等;</li><li>如果两个对象<code>x.equals(y)</code>方法返回<code>false</code>，则<code>x</code>、 <code>y</code>这两个对象的<code>hashCode</code>可以相等也可以不等。但是，为不相等的对象生成不同整数结果可以提高哈希表的性能。</li><li>默认的<code>hashCode</code>是将内存地址转换为的<code>hash</code>值，重写过后就是自定义的计算方式；也可以通过<code>System.identityHashCode(Object)</code>来返回原本的 <code>hashCode</code>。</li></ol><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于比较当前对象与目标对象是否相等，默认是比较引用是否指向同一对象。为<code>public</code>方法，子类可重写。</p><p><strong>为什么需要重写<code>equals</code>方法？</strong></p><p><strong>因为如果不重写equals方法，当将自定义对象放到<code>map</code>或者<code>set</code>中时</strong>；如果这时两个对象的 <code>hashCode</code>相同，就会调用 <code>equals</code>方法进行比较，这个时候会调用 <code>Object</code>中默认的<code>equals</code>方法，而默认的<code>equals</code>方法只是比较了两个对象的引用是否指向了同一个对象，显然大多数时候都不会指向，这样就会将重复对象存入<code>map</code>或者<code>set</code>中。这就<strong>破坏了<code>map</code>与<code>set</code>不能存储重复对象的特性，会造成内存溢出</strong>。</p><p><strong>重写<code>equals</code>方法的几条约定：</strong></p><ol><li><strong>自反性</strong>：即 <code>x.equals(x)</code>返回 <code>true</code>， <code>x</code>不为 <code>null</code>；</li><li><strong>对称性</strong>：即 <code>x.equals(y)</code>与 <code>y.equals(x）</code>的结果相同， <code>x</code>与 <code>y</code>不为 <code>null</code>；</li><li><strong>传递性</strong>：即 <code>x.equals(y)</code>结果为 <code>true</code>, <code>y.equals(z)</code>结果为 <code>true</code>，则 <code>x.equals(z)</code>结果也必须为 <code>true</code>；</li><li><strong>一致性</strong>：即 <code>x.equals(y)</code>返回 <code>true</code>或 <code>false</code>，在未更改 <code>equals</code>方法使用的参数条件下，多次调用返回的结果也必须一致。 <code>x</code>与 <code>y</code>不为 <code>null</code>;</li><li>如果<code>x</code>不为<code>null</code>,<code>x.equals(null)</code>返回<code>false</code>。</li></ol><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure><p>此方法返回当前对象的一个副本。</p><p>这是一个<code>protected</code>方法，提供给子类重写。但需要实现<code>Cloneable</code>接口，这是一个标记接口，如果没有实现，当调用<code>object.clone()</code>方法，会抛出 <code>CloneNotSupportedException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneTest</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略getter、setter方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> CloneTest <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneTest) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">CloneTest</span> <span class="variable">cloneTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneTest</span>(<span class="number">23</span>, <span class="string">&quot;XX&quot;</span>);</span><br><span class="line">        <span class="type">CloneTest</span> <span class="variable">clone</span> <span class="operator">=</span> cloneTest.clone();</span><br><span class="line">        System.out.println(clone == cloneTest);</span><br><span class="line">        System.out.println(cloneTest.getAge() == clone.getAge());</span><br><span class="line">        System.out.println(cloneTest.getName() == clone.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从输出我们看见，<code>clone</code>的对象是一个新的对象；但原对象与<code>clone</code>对象的<code>String</code>类型的<code>name</code>却是同一个引用，这表明，<code>super.clone</code>方法对成员变量如果是引用类型的，进行是浅拷贝。</p><p><strong>那如果我们要进行深拷贝怎么办呢？</strong> </p><p>答案是：如果成员变量是引用类型，想实现深拷贝，则成员变量也要实现<code>Cloneable</code>接口，重写<code>clone</code>方法。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个<code>public</code>方法，子类可重写，建议所有子类都重写 <code>toString</code>方法，默认的 <code>toString</code>方法，只是将当前类的全限定性类名 <code>+@+</code>十六进制的 <code>hashCode</code>值。</p><p>我们思考一下为什么需要toString方法？</p><p>可以这么理解：返回当前对象的字符串表示，可以将其打印方便查看对象的信息，方便记录日志信息提供调试。我们可以选择需要表示的重要信息重写到 <code>toString</code>方法中。</p><h3 id="wait-wait-long-wait-long-int"><a href="#wait-wait-long-wait-long-int" class="headerlink" title="wait()&#x2F;wait(long)&#x2F;wait(long,int)"></a>wait()&#x2F;wait(long)&#x2F;wait(long,int)</h3><p><code>wait()</code>方法还有两个带参数的重载方法： <code>wait(long)</code> 、 <code>wait(long,int)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                            <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个方法是用来线程间通信用的，作用是阻塞当前线程，等待其他线程调用<code>notify()/notifyAll()</code>方法将其唤醒。这些方法都是<code>public final</code>的，不可被重写。</p><p>注意：</p><ol><li>此方法只能在当前线程获取到对象的锁监视器之后才能调用，否则会抛出<code>IllegalMonitorStateException</code>异常。</li><li>调用<code>wait</code>方法，线程会将锁监视器进行释放；而<code>Thread.sleep，Thread.yield()</code>并不会释放锁。</li><li><code>wait</code>方法会一直阻塞，直到其他线程调用当前对象的 <code>notify()/notifyAll()</code>方法将其唤醒；而 <code>wait(long)</code>是等待给定超时时间内（单位毫秒），如果还没有调用<code>notify()/nofiyAll()</code>会自动唤醒；<code>wait(long,int)</code>如果第二个参数大于<code>0</code>并且小于<code>999999</code>，则第一个参数<code>+1</code>作为超时时间；</li></ol><h3 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify()&#x2F;notifyAll()"></a>notify()&#x2F;notifyAll()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>前面说了，如果当前线程获得了当前对象锁，调用<code>wait</code>方法，将锁释放并阻塞；这时另一个线程获取到了此对象锁，并调用此对象的 <code>notify()/notifyAll()</code>方法将之前的线程唤醒。这些方法都是<code>public final</code>的，不可被重写。</p><ol><li><code>public final native void notify();</code> 随机唤醒之前在当前对象上调用<code>wait</code>方法的一个线程;</li><li><code>public final native void notifyAll()</code>; 唤醒所有之前在当前对象上调用<code>wait</code>方法的线程</li></ol><p><strong>注意</strong>：调用<code>notify()</code>后，阻塞线程被唤醒，可以参与锁的竞争，但可能调用<code>notify()</code>方法的线程还要继续做其他事，锁并未释放，所以我们看到的结果是，无论<code>notify()</code>是在方法一开始调用，还是最后调用，阻塞线程都要等待当前线程结束才能开始。</p><p>为什么<code>wait()/notify()</code>方法要放到<code>Object</code>中呢？ </p><p>因为每个对象都可以成为锁监视器对象，所以放到<code>Object</code>中，可以直接使用。</p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><p>此方法是在垃圾回收之前，JVM会调用此方法来清理资源。此方法可能会将对象重新置为可达状态，导致JVM无法进行垃圾回收。</p><p>我们知道Java相对于C++很大的优势是程序员不用手动管理内存，内存由JVM管理；如果我们的引用对象在堆中没有引用指向他们时，当内存不足时，JVM会自动将这些对象进行回收释放内存，这就是我们常说的垃圾回收。但垃圾回收没有讲述的这么简单。</p><p><strong><code>finalize()</code>方法具有如下4个特点：</strong></p><ol><li>永远不要主动调用某个对象的<code>finalize()</code>方法，该方法由垃圾回收机制自己调用；</li><li><code>finalize()</code>何时被调用，是否被调用具有不确定性；</li><li>当<code>JVM</code>执行可恢复对象的 <code>finalize()</code>可能会将此对象重新变为可达状态；</li><li>当<code>JVM</code>执行<code>finalize()</code>方法时出现异常，垃圾回收机制不会报告异常，程序继续执行。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单谈谈锁</title>
      <link href="/posts/27218.html"/>
      <url>/posts/27218.html</url>
      
        <content type="html"><![CDATA[<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p>从各种不同角度出发，可以对Java中的锁进行分类，这些分类并不是互斥的，也就是多个类型可以并存，有可能一个锁同时属于两种类型，比如ReentrantLock既是互斥锁，又是可重入锁。</p><p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/20231003_1696305899723.jpg" alt="20231003_1696305899723.jpg"></p><h2 id="悲观锁VS乐观锁"><a href="#悲观锁VS乐观锁" class="headerlink" title="悲观锁VS乐观锁"></a>悲观锁VS乐观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>如果我不锁住这个资源，别人就会来争抢，就会造成数据结果错误，所以每次悲观锁为了确保结果的正确性，会在每次获取并修改数据时，把数据锁住，让别人无法访问该数据，这样就可以确保数据内容万无一失。</p><p>Java中悲观锁的实现就是synchronized和Lock相关类。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>认为自己在处理操作的时候不会有其他线程来干扰，所以并不会锁住被操作对象。在提交更新的时候，去对比在我修改的期间数据有没有被其他人改变过，如果没被改变过，就说明真的是只有我自己在操作，那我就正常去修改数据。</p><p>如果数据和我一开始拿到的不一样了，说明其他人在这段时间内改过数据，那我就不能继续刚才的更新数据过程了，我会选择报错、重试等策略。</p><p>乐观锁的实现一般都是利用CAS算法来实现的。</p><h3 id="开销对比"><a href="#开销对比" class="headerlink" title="开销对比"></a>开销对比</h3><p>悲观锁的原始开销要高于乐观锁，但是特点是一劳永逸，临界区持锁时间就算越来越差，也不会对互斥锁的开销造成影响。<br>相反，虽然乐观锁一开始的开销比悲观锁小，但是如果自旋时间很长或者不停重试，那么消耗的资源也会越来越多。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>悲观锁：适合并发写入多的情况，适用于临界区持锁时间比较长的情况，悲观锁可以避免大量的无用自旋等消耗，</p><p>典型情况:</p><ul><li>临界区有IO操作</li><li>临界区代码复杂或循环量大</li><li>临界区竞争非常激烈</li></ul><p>乐观锁：适合并发写入少，大部分是读取的场景，不加锁的能让读取性能大幅提高。</p><h2 id="公平锁VS非公平锁"><a href="#公平锁VS非公平锁" class="headerlink" title="公平锁VS非公平锁"></a>公平锁VS非公平锁</h2><p>公平指的是按照线程请求的顺序，来分配锁，非公平指的是不完全按照请求的顺序，在一定情况下，可以插队。</p><table><thead><tr><th></th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>公平锁</td><td>各线程公平平等，每个线程在等待一段时间后，总有执行的机会</td><td>更慢，吞吐量小</td></tr><tr><td>非公平锁</td><td>更快，吞吐量大</td><td>有可能产生线程饥饿，也就是某些线程长时间内始终得不到执行</td></tr></tbody></table><h2 id="共享锁VS排他锁"><a href="#共享锁VS排他锁" class="headerlink" title="共享锁VS排他锁"></a>共享锁VS排他锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>共享锁，又称为读锁，获得共享锁之后，可以查看但无法修改和删除数据，其他线程此时也可以获取到共享锁，也可以查看但无法修改和删除数据。</p><p>排他锁，又称为独占锁、独享锁。</p><p>共享锁和排它锁的典型是读写锁ReentrantReadWriteLock，其中读锁是共享锁，写锁是独享锁。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁的作用</p><p>在没有读写锁之前，我们假设使用ReentrantLock,那么虽然我们保证了线程安全，但是也浪费了一定的资源。多个读操作同时进行，并没有线程安全问题<br>在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的提高了程序的执行效率。</p><p>读写锁规则</p><ul><li>多个线程只申请读锁，都可以申请到。</li><li>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。</li><li>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</li><li>一句话总结：要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现（要么多读，要么一写）。</li></ul><p>换一种思路更容易理解：读写锁只是一把锁，可以通过两种方式锁定读锁定和写锁定。读写锁可以同时被一个或多个线程读锁定，也可以被单一线程写锁定。但是永远不能同时对这把锁进行读锁定和写锁定。</p><blockquote><p>这里是把“获取写锁”理解为“把读写锁进行写锁定”，相当于是换了一种思路，不过原则是不变的，就是要么是一个或多个线程同时有读锁（同时读锁定），要么是一个线程有写锁（进行写锁定），但是两者不会同时出现。</p></blockquote><h2 id="自旋锁VS阻塞锁"><a href="#自旋锁VS阻塞锁" class="headerlink" title="自旋锁VS阻塞锁"></a>自旋锁VS阻塞锁</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。</p><p>如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁，而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是<strong>自旋锁</strong>。</p><p>阻塞锁和自旋锁相反，阻塞锁如果遇到没拿到锁的情况，会直接把线程阻塞，直到被唤醒</p><p><strong>自旋锁的缺点</strong></p><p>如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。在自旋的过程中，一直消耗cpu，所以虽然自旋锁的起始开销低于悲观锁，但是随着自旋时间的增长，开销也是线性增长的。</p><p><strong>自旋锁的适用场景</strong></p><p>自旋锁一般用于多核的服务器，在并发度不是特别高的情况下，比阻塞锁的效率高。<br>另外，自旋锁适用于临界区比较短小的情况，否则如果临界区很大（线程一旦拿到锁，很久以后才会释放），不太合适。</p><h2 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h2><p>在Java中，synchronized就不是可中断锁，而lock是可中断锁，因为<code>tryLock(time)</code>和<code>lockInterruptibly</code>都能响应中断。</p><p>如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁可能由于等待时间过长，线程B不想等待了，想先处理其他事情我们可以中断它，这种就是可中断锁。</p><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>锁是一种工具，用于控制对共享资源的访问。<br>Lock和synchronized，这两个是最常见的锁，它们都可以达到线程安全的目的，但是在使用上和功能上又有较大的不同。Lock并不是用来代替synchronized的，而是当使用synchronized不合适或不足以满足要求的时候，来提供高级功能的。</p><h3 id="synchronized不足"><a href="#synchronized不足" class="headerlink" title="synchronized不足"></a>synchronized不足</h3><ul><li>效率低。锁的释放情况少、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程。</li><li>不够灵活。加锁和释放的时机单一，每个锁仅有单一的条件（某个对象)，可能是不够的。</li><li>无法知道是否成功获取到锁。</li></ul><h3 id="Lock获取锁方法"><a href="#Lock获取锁方法" class="headerlink" title="Lock获取锁方法"></a>Lock获取锁方法</h3><p>在Lock中声明了四个方法来获取锁：</p><ul><li>lock()</li><li>tryLock</li><li>tryLock(long time,TimeUnit unit)</li><li>lockInterruptibly()</li></ul><p>那么这四个方法有何区别呢？</p><p>lock()就是最普通的获取锁。如果锁已被其他线程获取，则进行等待; Lock不会像synchronized一样在异常时自动释放锁,因此最佳实践是，在finally中释放锁，以保证发生异常时锁一定被释放;lock()方法不能被中断，这会带来很大的隐患：一旦陷入死锁Iock()就会陷入永久等待。</p><p>tryLock()用来尝试获取锁，如果当前锁没有被其他线程占用则获取成功，则返回true,否则返回false，代表获取锁失败。相比于lock()，这样的方法显然功能更强大了，我们可以根据是否能获取到锁来决定后续程序的行为。该方法会立即返回，即便在拿不到锁时不会一直在那等。</p><p>tryLock(long time, TimeUnit unit)添加了超时时间。</p><p>lockInterruptibly()相当于tryLock(long time, TimeUnit unit)，把超时时间设置为无限。在等待锁的过程中，线程可以被中断。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
