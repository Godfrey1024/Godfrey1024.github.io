<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL分库分表</title>
      <link href="/posts/7417.html"/>
      <url>/posts/7417.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>互联网业务兴起之后，海量用户加上海量数据的特点，单个数据库服务器已经难以满足业务发展的需求，必须考虑数据库集群的方式来提升性能。</p><p>高性能数据库集群的特点：</p><ol><li><p>读写分离。</p></li><li><p>数据库分片。</p></li></ol><h2 id="读写分离架构"><a href="#读写分离架构" class="headerlink" title="读写分离架构"></a>读写分离架构</h2><p>读写分离的原理：就是将数据库的读写操作分散到不同的节点上。下面是其基本的架构图：</p><p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/202310190110627.png" alt="202310190110627.png"></p><p>读写分离的基本实现：</p><ul><li><p>主库负责处理事务性的增删改操作，从库负责处理查询操作，这样能够有效的避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善。</p></li><li><p>读写分离是根据 SQL 语义的分析，将读操作和写操作分别路由到主库和从库的。</p></li><li><p>通过一主多从的配置方式，可以将查询请求均匀的分散到多个数据副本，能够进一步的提升系统的处理能力。</p></li><li><p>使用多主多从的配置方式，不但能够提升系统的吞吐量，还能够提升系统的可用性（甚至任何一个数据库宕机或者磁盘损坏的情况下依然不影响系统的正常运行）。</p></li></ul><p>下图展示了根据业务需求，将用户表的写操作和读操作路由到不同的数据库的方案：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/202310190110027.png" alt="202310190110027.png" style="zoom:67%;" /><h2 id="数据库分片架构"><a href="#数据库分片架构" class="headerlink" title="数据库分片架构"></a>数据库分片架构</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>读写分离的问题：读写分离可以解决海量用户并发访问的压力，因为读写分离将并发的读操作和写操作分散到了不同的数据库中，从而分散了单台数据库并发读写操作的压力，但是并没有分散存储压力，为了满足业务数据存储的需求，就需要将存储分散到多台数据库服务器上。</p><p>数据分片：将存放在单一数据库中的数据分散的存放到多个数据库或表中，以达到提升性能瓶颈以及可用性的效果。数据分片的有效手段是对关系型数据库进行分库分表。数据分片的拆分方式又分为 垂直分片 和 水平分片。</p><h4 id="垂直分片之垂直分库"><a href="#垂直分片之垂直分库" class="headerlink" title="垂直分片之垂直分库"></a>垂直分片之垂直分库</h4><p>按照业务拆分的方式称为垂直分片，又称为纵向拆分，它的核心理念是专库专用。在拆分之前，一个数据库由多个数据表构成，每个表对应着不同的业务。而拆分之后，则是按照业务将表进行归类，分布到不同的数据库中，从而将压力分散至不同的数据库中。</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231020210443294.png" alt="image-20231020210443294" style="zoom:67%;" /><p>下图展示了根据业务需求，将用户表和订单表垂直分片到不同的数据库的方案：</p> <img src="https://qiniu.chengke.net/mysql/202310190110243.png" alt="img" style="zoom: 67%;" /><p>垂直拆分可以缓解数据量和访问量带来的问题，但是无法根治。如果垂直拆分之后，表中的数据量依然超过单节点所能承载的阈值，则需要水平分片来进一步处理。</p><blockquote><p>阿里巴巴 Java 开发手册：</p><p>【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。<br>说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p></blockquote><h4 id="垂直分片之垂直分表"><a href="#垂直分片之垂直分表" class="headerlink" title="垂直分片之垂直分表"></a>垂直分片之垂直分表</h4><p>垂直分表适合于将表中某些不常用的列，或者占用了大量空间的列拆分出去。</p><p>假设我们是一个婚恋网络，用户在筛选其他用户的时候，主要使用 age 和 sex 两个字段进行查询，而 nickname 和 description 两个字段主要用于展示，一般不会在业务查询中使用到。而 description 字段本身占用空间比较大，因为我们可以将 nickname 和 description 两个字段独立到另外一张包中，这样在查询 age 和 sex 的时候，就能带来一定的性能提升。</p><p>垂直分表引入的复杂性主要体现在表操作的数量的增加。比如，原来只要一次查询就可以获取 name、age、nickname、description ，现在需要两次查询：一次获取 name、age、sex，另外一次查询获取 nickname、description。并且新增的时候也可能需要维护两次。</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231020205908986.png" alt="image-20231020205908986" style="zoom: 67%;" /><blockquote><p>注意：水平分表适合表行数特别大的表，水平分表属于水平分片。</p></blockquote><h4 id="水平分片"><a href="#水平分片" class="headerlink" title="水平分片"></a>水平分片</h4><p>水平分片又称为横向拆分，相对于垂直分片，它不再将数据根据业务逻辑分类，而是通过某个字段（或某几个字段），根据某种规则将数据分散到多个库或表中，每个分片仅包含数据的一部分，比如：根据主键分片，偶数主键的记录放入 0 库（或表），奇数主键的记录放入 1 库（或表），如下图所示：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231020210057411.png" alt="image-20231020210057411" style="zoom: 67%;" /><blockquote><p>注意：单表进行切分后，是否将多个表分散在不同的数据库服务器中，可以根据实际切分的效果来确定。</p></blockquote><p>水平分表：单表切分为多表后，新的表即使在同一个数据库服务器中，也可能带来客观的性能提升；如果性能能够满足业务需要，可以不拆分到多台数据库服务器，毕竟业务分库会引入很多复杂性。</p><p>水平分库：如果单表拆分为多表后，单台服务器依然无法满足性能要求，那么就需要将多个表分散在不同的数据库服务器总。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>读写分离和数据分片具体的实现方式一般有两种：</p><p>① 程序代码封装。</p><p>② 中间件封装。</p><h3 id="程序代码封装"><a href="#程序代码封装" class="headerlink" title="程序代码封装"></a>程序代码封装</h3><p>程序代码封装指的是在代码中抽象一个 数据访问层（或中间层封装），实现读写操作分离和数据库服务器连接的管理。</p><p>其基本架构是：以读写分离为例</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231020210259318.png" alt="image-20231020210259318" style="zoom: 80%;" /><h3 id="中间件封装"><a href="#中间件封装" class="headerlink" title="中间件封装"></a>中间件封装</h3><p>中间件封装指的是 独立一套系统 出来，实现读写操作分离和数据库服务器连接的管理。对于业务服务器来说，访问中间件和访问数据库没有什么区别，在业务服务器看来，中间件就是一个数据库服务器。</p><p>其基本架构是：以读写分离为例</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231020210343563.png" alt="image-20231020210343563" style="zoom:67%;" /><h3 id="常见解决方案"><a href="#常见解决方案" class="headerlink" title="常见解决方案"></a>常见解决方案</h3><p>Shardingsphere：程序级别和中间件级别。</p><p>MyCat：中间件级别。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> ShardingSphere </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP理论</title>
      <link href="/posts/44851.html"/>
      <url>/posts/44851.html</url>
      
        <content type="html"><![CDATA[<h2 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>CAP 理论（CAP theorem）又被称作布鲁尔理论（Brewer’s theorem），是加州大学伯克利分校的计算机科学家埃里克·布鲁尔（Eric Brewer）在 2000 年的 ACM PODC 上提出的一个猜想。对于设计分布式系统的架构师来说，CAP 是必须掌握的理论。</p><p>在一个分布式系统中，当涉及到读写操作的时候，只能保证一致性（Consistency）、可用性（Availability）、分区容错性（Partition Tolerance）三者中的两个，另一个必须被牺牲。</p><p>C 就是一致性（Consistency ）：对某个指定的客户端来说，读操作保证能够返回最新的写操作结果。</p><p>A 就是可用性（Availability）：非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应），有可能不是最新的数据，而是旧的数据。</p><p>P 就是分区容错性（Partition Tolerance）：当出现网络分区后，系统能够继续 “履行职责”。</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/202310190110812.jpeg" alt="202310190110812.jpeg" style="zoom: 80%;" /><h3 id="CAP-的理解"><a href="#CAP-的理解" class="headerlink" title="CAP 的理解"></a>CAP 的理解</h3><p>CAP 是描述性理论，不是工程理论，它舍弃了很多现实世界中的问题，比如：网络波动、丢包、节点处理速度不一致等问题。</p><p>在一个分布式系统中，节点组成的网络本来应该是互相连通的，但是因为一些故障（网络波动、丢包、节点处理速度不一样等），使得有些节点之间不能互通，那么整个网络就分成了几块区域。数据就散布在了这些不连通的区域中，这就是分区。</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231020210507215.png" alt="image-20231020210507215" style="zoom: 80%;" /><p>当一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了，这个时候分区是无法容忍的。</p><p>提高分区容忍性的办法就是将一个数据项复制到多个节点上，那么出现分区之后，这一数据项就有可能分布到各个区里面，那么容忍性就提高了；换言之，任意客户端（如：Java 等）连接到各个节点的服务器上都有数据了，虽然可能是旧数据，就像上图中的 Redis 一样。</p><p>但是，要将数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据有可能不一致。如果要一致，每次写操作都需要等待全部节点成功（强一致性，在现在的分布式系统中，想保证实时强一致性几乎不太可能，追求的是最终一致性），其中最差的方案（性能最差）就是写的时候加锁，写完之后释放锁；但是在各个节点在写的时候，如果有客户端又发送了写请求，就会出现可用性问题。那么什么是可用性问题？如果一个客户端在合理的时间内和服务器进行通信，一直死活连不上，或者一直报超时，甚至是 ERROR，客户端就会觉得服务器可能已经宕机。</p><p>总体来说，数据存在的节点越多，分区容忍性就越高，但是复制更新的数据就越多，一致性就难以保证。为了保证一致性，更新所有节点所需要花费的时间就越长，可用性就会降低。</p><blockquote><p>注意：</p><p>C（一致性）就是客户端是否能拿到最新数据，不是所谓的强一致性。<br>A（可用性）就是允许客户端拿不到最近的数据，但是可以是旧的数据；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Github托管项目</title>
      <link href="/posts/60316.html"/>
      <url>/posts/60316.html</url>
      
        <content type="html"><![CDATA[<h2 id="GitHub托管本地项目"><a href="#GitHub托管本地项目" class="headerlink" title="GitHub托管本地项目"></a>GitHub托管本地项目</h2><p>Git连接远程仓库时支持两种协议，SSH和HTTPS。</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231021161413637.png" alt="image-20231021161413637" style="zoom:67%;" /><h3 id="SSH连接"><a href="#SSH连接" class="headerlink" title="SSH连接"></a>SSH连接</h3><h4 id="生成SSH秘钥对"><a href="#生成SSH秘钥对" class="headerlink" title="生成SSH秘钥对"></a>生成SSH秘钥对</h4><p>在本地打开GitBash窗口，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>   <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231021161937546.png" alt="image-20231021161937546" style="zoom: 80%;" /><p>​生成成功的话，在C盘用户目录下会有一个名为.ssh的目录，里面是ssh的公钥和私钥文件。</p><p>​<img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231021162238891.png" alt="image-20231021162238891"></p><h4 id="配置公钥到Github账户"><a href="#配置公钥到Github账户" class="headerlink" title="配置公钥到Github账户"></a>配置公钥到Github账户</h4><p>第一步：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231021162724854.png" alt="image-20231021162724854" style="zoom: 50%;" /><p>第二步：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231021163020266.png" alt="image-20231021163020266" style="zoom:67%;" /><h4 id="配置本地项目"><a href="#配置本地项目" class="headerlink" title="配置本地项目"></a>配置本地项目</h4><p>第一步,查看当前git的远程仓库版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br></pre></td></tr></table></figure><p>此时若什么都没有显示说明，git无远程仓库。</p><p>第二步，添加ssh协议的远程仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add 名称 远程仓库ssh地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">名称任意，远程仓库我们一般命名为<span class="string">&quot;origin&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">远程仓库ssh地址，我们直接从Github粘贴过来，防止写错</span></span><br></pre></td></tr></table></figure> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231021163714702.png" alt="image-20231021163714702" style="zoom:67%;" /><p>再次查看，此时本地项目已经和远程仓库关联起来了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin  git@github.com:Godfrey1024/Godfrey1024.github.io.git</span><br><span class="line">origin  git@github.com:Godfrey1024/Godfrey1024.github.io.git</span><br></pre></td></tr></table></figure><p>ssh连接的好处是每次提交代码时，不需要重复来回输入用户名和密码。</p><p>有的时候拉取合并代码的时候，会报出如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull origin master</span></span><br><span class="line">ssh: connect to host github.com port 22: Connection refused</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure><p>大概率是由于当前网络的原因，当前网络禁止SSH协议的22端口，尤其是公司企业网络。那么只能换一种连接进行合并本地仓库了。</p><h3 id="HTTPS连接"><a href="#HTTPS连接" class="headerlink" title="HTTPS连接"></a>HTTPS连接</h3><p>依然是先查看当前远程仓库使用的那种协议连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin  git@github.com:Godfrey1024/Godfrey1024.github.io.git</span><br><span class="line">origin  git@github.com:Godfrey1024/Godfrey1024.github.io.git</span><br></pre></td></tr></table></figure><p>移除掉远程仓库的配置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote <span class="built_in">rm</span> origin</span></span><br></pre></td></tr></table></figure><p>重新添加新的远程仓库，以https的形式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/Godfrey1024/Godfrey1024.github.io.git</span><br></pre></td></tr></table></figure> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231023124842105.png" alt="image-20231023124842105" style="zoom:67%;" /><p>完成以上切换操作，其实问题就已经解决了。</p><p>再次尝试pull代码，可以看到已经成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull origin master</span></span><br><span class="line">remote: Counting objects: 21, done.</span><br><span class="line">remote: Compressing objects: 100% (8/8), done.</span><br><span class="line">Unpacking objects: 100% (21/21), done.</span><br><span class="line">remote: Total 21 (delta 5), reused 21 (delta 5), pack-reused 0</span><br><span class="line">From https://github.com/Godfrey1024/Godfrey1024.github.io</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line"> * [new branch]      master     -&gt; origin/master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hasCode生成逻辑</title>
      <link href="/posts/38529.html"/>
      <url>/posts/38529.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>先抛出一个问题：Object类中hashCode方法的返回值是对象的内存地址值吗？</p><p>hashCode方法是一个本地方法，Object类中是这样声明的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h2 id="简单的打印"><a href="#简单的打印" class="headerlink" title="简单的打印"></a>简单的打印</h2><p>先看一个最简单的打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">System.out.println(o);</span><br></pre></td></tr></table></figure><p>会输出该类的全限定类名和一串字符串：<code>java.lang.Object@6659c656</code></p><p><code>@</code>符号后面的是什么？是hashcode值还是对象的内存地址？还是其他的什么值？</p><p>其实<code>@</code>后面的只是对象的hashcode值，以16进制展示的hashcode值而已，来验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">hashcode</span> <span class="operator">=</span> o.hashCode();</span><br><span class="line"><span class="comment">// toString</span></span><br><span class="line">System.out.println(o);</span><br><span class="line"><span class="comment">// hashcode 十六进制</span></span><br><span class="line">System.out.println(Integer.toHexString(hashcode));</span><br><span class="line"><span class="comment">// hashcode</span></span><br><span class="line">System.out.println(hashcode);</span><br><span class="line"><span class="comment">// 下面这个方法，也是获取对象的 hashcode；不过和 Object.hashcode 不同的是，该方法会无视重写的hashcode</span></span><br><span class="line">System.out.println(System.identityHashCode(o));</span><br><span class="line"></span><br><span class="line">#######输出结果###########</span><br><span class="line">java.lang.Object@6659c656</span><br><span class="line">6659c656</span><br><span class="line"><span class="number">1717159510</span></span><br><span class="line"><span class="number">1717159510</span></span><br></pre></td></tr></table></figure><p>打印输出一个对象时，默认调用该对象的toString方法，从Object类中的toString方法的实现也可以确定@<code>@</code>后面的只是对象的hashcode值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那对象的hashcode值到底是怎么生成的呢？真的就是内存地址吗？</p><p>下面我们一步步深入JDK源码，看一下hashCode方法是怎么实现的，再回答上面的问题。</p><h2 id="hashCode实现"><a href="#hashCode实现" class="headerlink" title="hashCode实现"></a>hashCode实现</h2><p><strong>基于 Java8 HotSpot</strong></p><p>JVM里hashCode方法的实现并没有那么简单，它提供了好几种策略，每种策略的生成结果都不同。</p><p>来看一下OpenJDK源码里，实现hashCode方法的核心方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">intptr_t</span> <span class="title">get_next_hash</span><span class="params">(Thread * Self, oop obj)</span> </span>&#123;</span><br><span class="line">  <span class="type">intptr_t</span> value = <span class="number">0</span> ;</span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// This form uses an unguarded global Park-Miller RNG,</span></span><br><span class="line">     <span class="comment">// so it&#x27;s possible for two threads to race and generate the same RNG.</span></span><br><span class="line">     <span class="comment">// On MP system we&#x27;ll have lots of RW access to a global, so the</span></span><br><span class="line">     <span class="comment">// mechanism induces lots of coherency traffic.</span></span><br><span class="line">     value = os::<span class="built_in">random</span>() ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">// This variation has the property of being stable (idempotent)</span></span><br><span class="line">     <span class="comment">// between STW operations.  This can be useful in some of the 1-0</span></span><br><span class="line">     <span class="comment">// synchronization schemes.</span></span><br><span class="line">     <span class="type">intptr_t</span> addrBits = <span class="built_in">intptr_t</span>(obj) &gt;&gt; <span class="number">3</span> ;</span><br><span class="line">     value = addrBits ^ (addrBits &gt;&gt; <span class="number">5</span>) ^ GVars.stwRandom ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">2</span>) &#123;</span><br><span class="line">     value = <span class="number">1</span> ;            <span class="comment">// for sensitivity testing</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">3</span>) &#123;</span><br><span class="line">     value = ++GVars.hcSequence ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">4</span>) &#123;</span><br><span class="line">     value = <span class="built_in">intptr_t</span>(obj) ;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Marsaglia&#x27;s xor-shift scheme with thread-specific state</span></span><br><span class="line">     <span class="comment">// This is probably the best overall implementation -- we&#x27;ll</span></span><br><span class="line">     <span class="comment">// likely make this the default in future releases.</span></span><br><span class="line">     <span class="type">unsigned</span> t = Self-&gt;_hashStateX ;</span><br><span class="line">     t ^= (t &lt;&lt; <span class="number">11</span>) ;</span><br><span class="line">     Self-&gt;_hashStateX = Self-&gt;_hashStateY ;</span><br><span class="line">     Self-&gt;_hashStateY = Self-&gt;_hashStateZ ;</span><br><span class="line">     Self-&gt;_hashStateZ = Self-&gt;_hashStateW ;</span><br><span class="line">     <span class="type">unsigned</span> v = Self-&gt;_hashStateW ;</span><br><span class="line">     v = (v ^ (v &gt;&gt; <span class="number">19</span>)) ^ (t ^ (t &gt;&gt; <span class="number">8</span>)) ;</span><br><span class="line">     Self-&gt;_hashStateW = v ;</span><br><span class="line">     value = v ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  value &amp;= markOopDesc::hash_mask;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="number">0</span>) value = <span class="number">0xBAD</span> ;</span><br><span class="line">  <span class="built_in">assert</span> (value != markOopDesc::no_hash, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">TEVENT</span> (hashCode: GENERATE) ;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码里可以发现，生成策略是由一个 <code>hashCode</code> 的全局变量控制的，默认为5；而这个变量的定义在另一个头文件里：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">product</span>(intx, hashCode, <span class="number">5</span>,<span class="string">&quot;(Unstable) select hashCode generation algorithm&quot;</span> )</span><br></pre></td></tr></table></figure><p>源码里也说明了：”(Unstable) select hashCode generation algorithm,（非稳定）选择 hashCode 生成的算法”，而且这里的定义，是可以由 jvm 启动参数来控制的，先来确认下默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version | grep hashCode</span><br><span class="line"></span><br><span class="line">intx hashCode = 5 &#123;product&#125;</span><br><span class="line">openjdk version &quot;1.8.0_282&quot;</span><br><span class="line">OpenJDK Runtime Environment (AdoptOpenJDK)(build 1.8.0_282-b08)</span><br><span class="line">OpenJDK 64-Bit Server VM (AdoptOpenJDK)(build 25.282-b08, mixed mode)</span><br></pre></td></tr></table></figure><p>所以我们可以通过 jvm 的启动参数来配置不同的hashcode生成算法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:hashCode=N</span><br></pre></td></tr></table></figure><h3 id="第0种算法"><a href="#第0种算法" class="headerlink" title="第0种算法"></a>第0种算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hashCode == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// This form uses an unguarded global Park-Miller RNG,</span></span><br><span class="line">     <span class="comment">// so it&#x27;s possible for two threads to race and generate the same RNG.</span></span><br><span class="line">     <span class="comment">// On MP system we&#x27;ll have lots of RW access to a global, so the</span></span><br><span class="line">     <span class="comment">// mechanism induces lots of coherency traffic.</span></span><br><span class="line">     value = os::<span class="built_in">random</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这种生成算法，使用的一种 <code>Park-Miller RNG</code> 的随机数生成策略。不过需要注意的是, 这个随机算法在高并发的时候会出现自旋等待的情况。</p><h3 id="第1种算法"><a href="#第1种算法" class="headerlink" title="第1种算法"></a>第1种算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hashCode == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// This variation has the property of being stable (idempotent)</span></span><br><span class="line">    <span class="comment">// between STW operations.  This can be useful in some of the 1-0</span></span><br><span class="line">    <span class="comment">// synchronization schemes.</span></span><br><span class="line">    <span class="type">intptr_t</span> addrBits = <span class="built_in">intptr_t</span>(obj) &gt;&gt; <span class="number">3</span> ;</span><br><span class="line">    value = addrBits ^ (addrBits &gt;&gt; <span class="number">5</span>) ^ GVars.stwRandom ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法，真的是对象的内存地址了，直接获取对象的 <code>intptr_t 类型指针</code>。</p><h3 id="第2种算法"><a href="#第2种算法" class="headerlink" title="第2种算法"></a>第2种算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hashCode == <span class="number">2</span>) &#123;</span><br><span class="line">    value = <span class="number">1</span> ;         <span class="comment">// for sensitivity testing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就不用解释了……<code>固定返回 1</code>，应该是用于内部的测试场景。</p><p>有兴趣的同学，可以试试-XX:hashCode&#x3D;2来开启这个算法，看看 hashCode 结果是不是都变成 1 了。</p><h3 id="第3种算法"><a href="#第3种算法" class="headerlink" title="第3种算法"></a>第3种算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hashCode == <span class="number">3</span>) &#123;</span><br><span class="line">    value = ++GVars.hcSequence ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法也很简单，自增嘛，所有对象的 hashCode 都使用这一个<code>自增变量</code>。来试试效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"></span><br><span class="line">#####输出结果#######</span><br><span class="line">java.lang.Object@<span class="number">144</span></span><br><span class="line">java.lang.Object@<span class="number">145</span></span><br><span class="line">java.lang.Object@<span class="number">146</span></span><br><span class="line">java.lang.Object@<span class="number">147</span></span><br><span class="line">java.lang.Object@<span class="number">148</span></span><br><span class="line">java.lang.Object@<span class="number">149</span></span><br></pre></td></tr></table></figure><p>果然是自增的。</p><h3 id="第4种算法"><a href="#第4种算法" class="headerlink" title="第4种算法"></a>第4种算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hashCode == <span class="number">4</span>) &#123;</span><br><span class="line">    value = intptr_t(obj) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和第1种算法其实区别不大，都是返回<code>对象地址</code>，只是第1种算法是一个变体。</p><h3 id="第5种算法"><a href="#第5种算法" class="headerlink" title="第5种算法"></a>第5种算法</h3><p>最后一种，<strong>也是默认的生成算法</strong>，hashCode配置不等于 0&#x2F;1&#x2F;2&#x2F;3&#x2F;4 时使用该算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Marsaglia&#x27;s xor-shift scheme with thread-specific state</span></span><br><span class="line">     <span class="comment">// This is probably the best overall implementation -- we&#x27;ll</span></span><br><span class="line">     <span class="comment">// likely make this the default in future releases.</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="variable">t</span> <span class="operator">=</span> Self-&gt;_hashStateX ;</span><br><span class="line">     t ^= (t &lt;&lt; <span class="number">11</span>) ;</span><br><span class="line">     Self-&gt;_hashStateX = Self-&gt;_hashStateY ;</span><br><span class="line">     Self-&gt;_hashStateY = Self-&gt;_hashStateZ ;</span><br><span class="line">     Self-&gt;_hashStateZ = Self-&gt;_hashStateW ;</span><br><span class="line">     <span class="type">unsigned</span> <span class="variable">v</span> <span class="operator">=</span> Self-&gt;_hashStateW ;</span><br><span class="line">     v = (v ^ (v &gt;&gt; <span class="number">19</span>)) ^ (t ^ (t &gt;&gt; <span class="number">8</span>)) ;</span><br><span class="line">     Self-&gt;_hashStateW = v ;</span><br><span class="line">     value = v ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里是通过当前状态值进行异或运算得到的一个hashcode值，相比前面的自增算法和随机算法来说效率更高，但重复率应该也会相对增高，不过 hashcode值重复又有什么关系呢……</p><p>本来jvm就不保证这个值一定不重复，像HashMap里的链地址法就是解决hash冲突用的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的介绍，我们知道默认情况下，对象的hashcode的生成算法是第5种，所以默认请求情况下hashcode值并不是对象的内存地址值。</p><p>注意：hashcode可以是内存地址，也可以不是内存地址，甚至可以是常数1或者自增数。想用什么算法，它都可以！</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8新特性-Lamda表达式</title>
      <link href="/posts/44073.html"/>
      <url>/posts/44073.html</url>
      
        <content type="html"><![CDATA[<p>在 Java8 之前，当实现只有一个方法的接口，我们通常是通过使用匿名内部类的方式来重写接口的方法，以 Comparator 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>Java8 中引入了 Lambda 表达式，提供了更加简洁的语法：<code>() -&gt; &#123;&#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">Collections.sort(list, (Integer o1, Integer o2) -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>从 Java8 开始编译器可以从接口的方法签名中自动推导出参数类型，因此可以省略掉类型的声明.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">Collections.sort(list, (o1, o2) -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>当方法体只有一行代码时，可以省略掉 {} 和 return 关键字以及代码行结束的分号“;”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">Collections.sort(list, (o1, o2) -&gt; o1.compareTo(o2));</span><br><span class="line">System.out.println(list); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>对于只有一个抽象方法的接口，都可以使用 Lambda 表达式。为了确保接口符合要求，可以使用 @FunctionalInterface 注解标注接口，被 @FunctionalInterface 注解标注的接口（称为函数式接口），只允许存在一个抽象方法，没有或多于一个抽象方法，编译都将无法通过。由于默认的方法不是抽象的，因此，函数式接口依然可以存在一个或多个默认方法。其中，每个 Lambda 表达式都将匹配函数式接口的这个抽象方法，Lambda 表达式的类型也由该接口类型决定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Operation</span>&lt;I, O&gt; &#123;</span><br><span class="line">O <span class="title function_">calculate</span><span class="params">(I input)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对函数式接口使用 Lambda 表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Operation&lt;Integer, Integer&gt; square = (i) -&gt; i * i;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> square.calculate(<span class="number">3</span>);</span><br><span class="line">System.out.println(result);<span class="comment">// 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK新特性 </tag>
            
            <tag> JDK8 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8新特性-接口默认方法</title>
      <link href="/posts/64503.html"/>
      <url>/posts/64503.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>在JDK8版本中，接口也可以为方法提供默认的实现，即接口也可以有自己的实现方法，具体的做法是使用关键字default即可为接口声明一个默认的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Predators</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;eat meat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何具体类在实现接口时，接口的默认方法不是必须实现的，非默认方法则必须实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Predators</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;wang....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口使用方面与平常无异，很自然。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">dog.doSomething();<span class="comment">// wang....</span></span><br><span class="line">dog.eat();<span class="comment">// eat meat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>关于多重继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Herbivore</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;eat fruit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下这段代码将无法通过编译。因 Predators 和 Herbivore 两个接口使用了同样签名的默认方法（eat），那么，在 Person 类中就无法确定最终使用哪个接口的默认实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Predators</span>, Herbivore &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;duang....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决冲突，你必须要通过手动重写的方式来修复。若想引用 Herbivore 接口中的 eat 方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Predators</span>, Herbivore &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">Herbivore.<span class="built_in">super</span>.eat();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;duang....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方面与平常无异，很自然。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person.doSomething();<span class="comment">// duang....</span></span><br><span class="line">person.eat();<span class="comment">// eat fruit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK新特性 </tag>
            
            <tag> JDK8 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>体会面向接口编程</title>
      <link href="/posts/42023.html"/>
      <url>/posts/42023.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>面向过程编程（ <code>ProcedureOriented</code>、简称 <code>PO</code>）</strong> 和 <strong>面向对象编程（ <code>ObjectOriented</code>、简称 <code>OO</code>）</strong> 我们一定听过，然而实际企业级开发里受用更多的一种编程思想那就是：<strong>面向接口编程（ <code>Interface-Oriented</code>）</strong>。</p><p>接口这个概念我们一定不陌生，实际生活中最常见的例子就是：插座。</p><p>我们只需要事先定义好插座的<strong>接口标准</strong>，各大插座厂商只要按这个接口标准生产，管你什么牌子、内部什么电路结构，这些均和用户无关，用户拿来就可以用；而且即使插座坏了，只要换一个符合接口标准的新插座，一切照样工作。</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231025082957760.png" alt="image-20231025082957760" style="zoom: 50%;" /><p>同理，实际代码设计也是这样。</p><p>我们在设计一个软件的代码架构时，我们都希望<strong>事先约定</strong>好各个功能的<strong>接口</strong>（即：约定好接口签名和方法），实际开发时我们只需要实现这个接口就能完成具体的功能。后续即使项目变化、功能升级，程序员只需要按照接口约定重新实现一下，就可以达到系统升级和扩展的目的。</p><p>正好，Java中天生就有 <code>interface</code>这个语法，这简直是为面向接口编程而生的！</p><p>所以接下来落实到代码上，举个通俗一点的例子，实际业务代码虽然比这个复杂，但原理是一模一样的。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>假设我有两辆“豪车”，一辆是五菱宏光，一辆是飞度，并且还专门聘请了一位驾驶员来帮助驾驶。那么我们需要定义三个类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WuLing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;驾驶五菱宏光汽车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;驾驶飞度汽车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 驾驶五菱宏光的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span> <span class="params">(Wuling wuling)</span> &#123;</span><br><span class="line">        wuling.drive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 驾驶飞度的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span> <span class="params">(Fit fit)</span> &#123;</span><br><span class="line">        fit.drive();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于测试功能的main方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化两辆新车</span></span><br><span class="line">        <span class="type">WuLing</span> <span class="variable">wuLing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WuLing</span>();</span><br><span class="line">        <span class="type">Fit</span> <span class="variable">fit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fit</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实例化驾驶员</span></span><br><span class="line">        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>();</span><br><span class="line">        <span class="comment">// 帮我开五菱宏光</span></span><br><span class="line">        driver.drive(wuLing);</span><br><span class="line">        <span class="comment">// 帮我开飞度</span></span><br><span class="line">        driver.drive(fit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果后面我发达了，又豪气地买了一辆新款奥拓（Alto）！可是现有的驾驶员类<code>Driver</code>的两个<code>drive()</code>方法里都开不了这辆新买的奥拓该怎么办呢？</p><h2 id="灵活解耦"><a href="#灵活解耦" class="headerlink" title="灵活解耦"></a>灵活解耦</h2><p>这时候，我想应该没有谁会专门再去往<code>Driver</code>类中添加一个新的<code>drive()</code>方法来达到目的吧？毕竟谁也不知道以后他还会不会买新车！</p><p>这时候如果我希望我聘请的这位驾驶员对于所有车型都能驾驭，该怎么办呢？</p><p>很容易想到，我们应该<strong>做一层抽象</strong>。毕竟不管是奥拓还是奥迪，它们都是汽车，因此我们<strong>定义一个父类</strong>叫做汽车类 <code>Car</code>，里面只声明一个通用的 <code>drive()</code>方法，具体怎么开先不用管：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象的汽车类Car，代表所有汽车</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Car</span>&#123;  </span><br><span class="line"><span class="comment">// 通用的汽车驾驶方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，只要我新买的奥拓符合<code>Car</code>定义的驾驶标准即可被我的驾驶员驾驶，所以只需要新的奥拓来继承一下 <code>Car</code>类即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alto</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;驾驶奥拓汽车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，只需要我的驾驶员具备通用汽车<code>Car</code>的驾驶能力，那驾驶所有的汽车都不是问题，因此<code>Drvier</code>类的<code>drive()</code>方法只要传入的参数是<strong>父类</strong>，那就具备了通用性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(Car car)</span> &#123;  <span class="comment">// 方法参数使用父类来替代</span></span><br><span class="line">        car.drive();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mian</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Alto</span> <span class="variable">alto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Alto</span>();</span><br><span class="line">        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>();</span><br><span class="line">        driver.drive(alto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再后来，我不想坐车了，想买一头马（Horse）让司机骑着带他出行！</p><p>很明显，原先适用于汽车的<code>drive()</code>方法肯定是不适合骑马的！但我们希望聘请的这位驾驶员既会开汽车，又会骑马怎么办呢？</p><p>我们干脆直接定义一个叫做交通工具（ <code>TrafficTools</code>）的通用接口吧！里面包含一个通用的交通工具使用方法，管你是驾驶汽车，还是骑驴骑马，具体技能怎么实现先不管：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的交通工具接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TrafficTool</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>;  <span class="comment">// 通用的交通工具的使用方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个<strong>接口约定</strong>，接下来就好办了。我们让所有的<code>Car</code>、或者驴、马等，都来实现这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">TrafficTool</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WuLing</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;驾驶五菱宏光&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fit</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;驾驶飞度&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alto</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;驾驶奥拓&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Horse</span> <span class="keyword">implements</span> <span class="title class_">TrafficTool</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;骑马&quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候只要我们的驾驶员师傅也<strong>面向接口编程</strong>，就没有任何问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line">    <span class="comment">// 方法参数面向接口编程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(TrafficTool trafficTool)</span> &#123;</span><br><span class="line">        trafficTool.drive();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(Strings[] args)</span> &#123;</span><br><span class="line">        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>();</span><br><span class="line">        driver.drive(<span class="keyword">new</span> <span class="title class_">WuLing</span>());  <span class="comment">// 驾驶五菱宏光</span></span><br><span class="line">        driver.drive(<span class="keyword">new</span> <span class="title class_">Fit</span>());  <span class="comment">// 驾驶飞度</span></span><br><span class="line">        driver.drive(<span class="keyword">new</span> <span class="title class_">Alto</span>());  <span class="comment">// 驾驶奥拓</span></span><br><span class="line">        driver.drive(<span class="keyword">new</span> <span class="title class_">Horse</span>());  <span class="comment">// 骑马</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，代码完全解耦了！这就是接口带来的便利。</p><h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2><p>面向接口编程的优点远不止上面这种代码解耦的场景，在实际企业开发里，利用接口思想<strong>对已有代码进行灵活扩展</strong>也特别常见。</p><p>再举一个例子：假设我有一个非常豪气的朋友，他们家出行可不坐车，全靠私人飞机出行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的飞机飞行接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Plane</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 朋友的专用机长，受过专业训练（即：实现了通用飞行接口）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlaneDriver</span> <span class="keyword">implements</span> <span class="title class_">Plane</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出门旅行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Travel</span> &#123;</span><br><span class="line">    <span class="comment">// 此处方法参数也是面向接口编程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">(Plane plane)</span> &#123;</span><br><span class="line">        plane.fly();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Travel</span> <span class="variable">travel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Travel</span>();  <span class="comment">// 开启一段旅行</span></span><br><span class="line">        <span class="type">PlaneDriver</span> <span class="variable">planeDriver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlaneDriver</span>();  <span class="comment">// 聘请一个机长</span></span><br><span class="line">        travel.fly(planeDriver);  <span class="comment">// 由机长开飞机带着全家去旅行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是突然有一天，他们家聘请的机长跳槽了，这时候我朋友他们一家就无法出行了，毕竟他们不会驾驶飞机。</p><p>于是他跑来问我借司机，想让我的驾驶员来帮他驾驶飞机出去旅行。</p><p>我一看，由于他们的代码面向的是接口，我就肯定地答应了他！</p><p>这时候对我这边的扩展来说就非常容易了，我只需要安排我的驾驶员去培训一下飞行技能就OK了（实现一个方法就行）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让我的驾驶员去培训一下飞行技能（即：去实现通用飞行接口）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">implements</span> <span class="title class_">Plane</span> &#123;</span><br><span class="line">    <span class="comment">// 方法参数面向接口编程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(TrafficTool trafficTool)</span> &#123;</span><br><span class="line">        trafficTool.drive();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现了fly()方法，这下我的驾驶员也具备操控飞机的能力了！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通驾驶员操控飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我的驾驶员 <code>Driver</code>类就可以直接服务于他们一家的出行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Travel</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">(Plane plane)</span> &#123;</span><br><span class="line">        plane.fly();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Travel</span> <span class="variable">travel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Travel</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 专业飞行员操控飞机</span></span><br><span class="line">        <span class="type">PlaneDriver</span> <span class="variable">planeDrvier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlaneDriver</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 普通驾驶员操控飞机</span></span><br><span class="line">        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>();</span><br><span class="line">        travle.fly(driver);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到没，这一改造过程中，我们只增加了代码，却并没有修改任何已有代码，就完成了代码扩展的任务，非常符合<strong>开闭原则</strong>！</p><h2 id="实际项目"><a href="#实际项目" class="headerlink" title="实际项目"></a>实际项目</h2><p>实际开发中，我们就暂且不说诸如<code>Spring</code>这种框架内部会大量使用接口，并对外提供使用，就连我们自己平时写业务代码，我们也习惯于在<code>Service</code>层使用接口来进行一层隔离：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231025140612057.png" alt="image-20231025140612057" style="zoom: 80%;" /><p>这种接口定义和具体实现逻辑的分开，非常有利于后续扩展和维护。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面向接口编程开发，对代码架构的解耦和扩展确实很有好处，这种编码思想也值得平时开发结合实践反复理解和回味。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建对象的几种姿势</title>
      <link href="/posts/6028.html"/>
      <url>/posts/6028.html</url>
      
        <content type="html"><![CDATA[<h2 id="关键字new"><a href="#关键字new" class="headerlink" title="关键字new"></a>关键字new</h2><p>用关键字<code>new</code>进行对象的创建，几乎是写代码时最常用的操作之一了，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>( <span class="string">&quot;Godfrey&quot;</span>, <span class="number">18</span>, <span class="number">65.0f</span> );</span><br></pre></td></tr></table></figure><p>通过<code>new</code>的方式，我们可以调用类的<strong>无参</strong>或者<strong>有参</strong>构造方法来实例化出一个对象。</p><p><code>new</code>一个对象的具体流程，用一张图可大致描述成如下所示：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027103259897.png" alt="image-20231027103259897" style="zoom: 67%;" /><ol><li>首先，当我们<code>new</code>一个对象时，比如<code>Person person = new Person()</code>，<code>JVM</code>首先就回去检查<code>Person</code>这个符号引用所代表的类是否已经被加载过，如果没有就要执行对应类的加载过程；</li><li>声明类型引用很简单，比如<code>Person person = new Person()</code>就会声明一个<code>Person</code>类型的引用<code>person</code>；</li><li>第一步类加载完成以后，对象所需的内存大小其实就已经确定下来了，接下来<code>JVM</code>就会在堆上为对象分配内存；</li><li>所谓的属性“<code>0</code>”值初始化非常好理解，即为实例化对象的各个属性赋上默认初始化“0”值，比如int的初始化0值就是0，而一个对象的初始化0值就是null；</li><li>接下来JVM会进行对象头的设置，这里面就主要包括对象的运行时数据（比如Hash码、分代年龄、锁状态标志、锁指针、偏向线程ID、偏向时间戳等）以及类型指针（JVM通过该类型指针来确定该对象是哪个类的实例）；</li><li>属性的显示初始化也好理解，比如定义一个类的时候，针对某个属性字段手动的赋值，如：<code>private String name = &quot;Godfrey&quot;;</code> 就在这时候给初始化上；</li><li>最后是调用类的构造方法来进行进行构造方法内描述的初始化动作。</li></ol><p>经过了这一系列步骤，一个新的可用对象方才得以诞生。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>学过Java反射机制的都知道，只要能拿到类的<code>Class</code>对象，就可以通过<strong>强大的反射机制</strong>来创造出实例对象了。</p><p>一般来说，拿到<code>Class</code>对象有三种方式：</p><ol><li><code>类名.class</code></li><li><code>对象名.getClass()</code></li><li><code>Class.forName(全限定类名)</code></li></ol><p>有了<code>Class</code>对象之后，接下来就可以调用其<code>newInstance()</code>方法来创建一个对象，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> (Person) Class.forName( <span class="string">&quot;ort.example.Person&quot;</span> ).newInstance();</span><br><span class="line"><span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> Person.class.newInstance();</span><br></pre></td></tr></table></figure><p>当然，这种方式的局限性也有目共睹，因为使用的是类的<strong>无参</strong>构造方法来创建的对象。</p><p>所以比这个更进一步的方式是通过<code>java.lang.relect.Constructor</code>这个类的<code>newInstance()</code>方法来创建对象，因为它可以明确指定某个构造器来创建对象。</p><p>比如，在我们拿到了类的<code>Class</code>对象后，就可以通过<code>getDeclaredConstructors()</code>函数来获取到类的所有构造函数列表，这样我们就可以调用对应的构造函数来创建对象了，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] constructors = Person.class.getDeclaredConstructors();</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> (Person) constructors[<span class="number">0</span>].newInstance(); </span><br><span class="line"><span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> (Person) constructors[<span class="number">1</span>].newInstance( <span class="string">&quot;Godfrey&quot;</span>, <span class="number">18</span>, <span class="number">65.1f</span> );</span><br></pre></td></tr></table></figure><p>而且，如果我们想明确获取类的某个构造函数，也可以在<code>getDeclaredConstructors()</code>函数里直接指定构造函数传参类型来精确控制，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> Person.class.getDeclaredConstructor( String.class, Integer.class, Float.class );</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) constructor.newInstance( <span class="string">&quot;Godfrey&quot;</span>, <span class="number">18</span>, <span class="number">65.2f</span> );</span><br></pre></td></tr></table></figure><h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><p>对象克隆在我们日常写代码的时候基本上是刚性需求，基于一个对象克隆出另一个对象，这也是写Java代码时十分常见的操作。</p><p>关于对象拷贝这一知识点，<strong>之前我就写过了</strong>，详细梳理过一篇：<a href="https://deepinfo.online/posts/49310.html">深拷贝VS浅拷贝</a>，里面详细梳理了对象赋值、拷贝、深拷贝、浅拷贝等系列知识点，本文便不再赘述了。</p><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>当我们作序列化和反序列化操作时，背后也会创建对象，关于「序列化和反序列化」这个知识点的详细理解+梳理，之前我也写过了，链接在此：<a href="https://deepinfo.online/posts/27710.html">理解序列化和反序列化</a></p><h2 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h2><p><code>Unsafe</code>类这个名字一听就有点悬了，的确，我们平时的业务代码里接触得好像并不多。</p><p>我们都知道写<code>Java</code>代码，很少会去操作位于底层的一些资源，比如内存等这些。而位于<code>sun.misc.Unsafe</code>包路径下的<code>Unsafe</code>类提供了一种直接访问系统资源的途径和方法，可以进行一些底层的操作。比如借助<code>Unsafe</code>我们就可以分配内存、创建对象、释放内存、定位对象某个字段的内存位置甚至并修改它等等。</p><p>可见这玩意误用时的破坏力是很大的，所以一般也都是受控使用的。业务代码里很少能看到它的身影，但是<code>JDK</code>内部的一些诸如<code>io</code>、<code>nio</code>、<code>juc</code>等包中的代码里还是有不少关于它的身影存在的。</p><p><code>Unsafe</code>类中有一个<code>allocateInstance()</code>方法，通过其就可以创建一个对象。为此我们只需要获取到一个<code>Unsafe</code>类的实例对象，我们自然就可以调用<code>allocateInstance()</code>来创建对象了。</p><p>那如何才能获取到一个<code>Unsafe</code>类的实例对象呢？</p><p>大致瞅一眼<code>Unsafe</code>类的源码我们就会发现，它是一个单例类，其构造方法是私有的，所以直接构造是不太现实了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Unsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">var0</span> <span class="operator">=</span> Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> theUnsafe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 省略 ...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且获取单例对象的入口函数<code>getUnsafe()</code>上也做了特殊标记，意思是只能从引导加载的类才可以调用该方法，这意味着该方法也是供<code>JVM</code>内部使用的，外部代码直接使用会报类似这样的异常：<code>Exception in thread &quot;main&quot; java.lang.SecurityException: Unsafe</code>。</p><p>走投无路，我们只能再次重拾强大的反射机制来创建<code>Unsafe</code>类的实例了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) f.get(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>然后接下来我们就可以愉快地利用它来创建对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) unsafe.allocateInstance( Person.class );</span><br></pre></td></tr></table></figure><h2 id="对象的隐式创建场景"><a href="#对象的隐式创建场景" class="headerlink" title="对象的隐式创建场景"></a>对象的隐式创建场景</h2><p>当然除了上述这几种<strong>显式地</strong>对象创建场景之外，还有一些我们并没有进行手动对象创建的隐式场景，举几个常见例子。</p><h3 id="Class类实例隐式创建"><a href="#Class类实例隐式创建" class="headerlink" title="Class类实例隐式创建"></a>Class类实例隐式创建</h3><p>我们都知道<code>JVM</code>虚拟机在加载一个类的时候，也都会创建一个类对应的<code>Class</code>实例对象，很明显这一过程是<code>JVM</code>偷偷地背着我们干的。</p><h3 id="字符串隐式对象创建"><a href="#字符串隐式对象创建" class="headerlink" title="字符串隐式对象创建"></a>字符串隐式对象创建</h3><p>典型的，比如定义一个<code>String</code>类型的字面变量时，就可能会引起一个新的<code>String</code>对象的创建，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Java YYDS!&quot;</span>;</span><br></pre></td></tr></table></figure><p>还有常见的比如<code>String</code>的<code>+</code>号连接符也会隐式地导致新<code>String</code>对象的创建等：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = str1 + str2;</span><br></pre></td></tr></table></figure><h3 id="自动装箱机制"><a href="#自动装箱机制" class="headerlink" title="自动装箱机制"></a>自动装箱机制</h3><p>这种例子也有很多，比如在执行类似如下代码时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>其触发的自动装箱机制就会导致一个新的包装类型的对象在后台被隐式地创建出来。</p><h3 id="函数可变参数"><a href="#函数可变参数" class="headerlink" title="函数可变参数"></a>函数可变参数</h3><p>比如像下面这样，当我们使用可变参数语法<code>int... nums</code>来描述一个函数的入参时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">( <span class="type">int</span>... nums )</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;length; ++i) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum/length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从表面上看，函数的调用处可以传入各种离散参数参与计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">avg( <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span> );</span><br><span class="line">avg( <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span> );</span><br><span class="line">avg( <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> );</span><br></pre></td></tr></table></figure><p>而背地里可能会隐式地产生一个对应的数组对象进行计算。</p><p>总而总之，很多场景下对象的隐式创建也是数见不鲜，我们最起码要做到心中大致有数。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/posts/7065.html"/>
      <url>/posts/7065.html</url>
      
        <content type="html"><![CDATA[<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列举出所以配置</span></span><br><span class="line">git config -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为命令配置别名</span></span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.br branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">git config [--global] user.name <span class="string">&quot;[name]&quot;</span></span><br><span class="line">git config [--global] user.email <span class="string">&quot;[email]&quot;</span></span><br></pre></td></tr></table></figure><p>Git全局配置文件位于 <code>~/.gitconfig</code></p><p>Git单个仓库的配置文件位于 <code>~/$PROJECT_PATH/.git/config</code></p><h2 id="增删文件"><a href="#增删文件" class="headerlink" title="增删文件"></a>增删文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括其子目录</span></span><br><span class="line">git add [<span class="built_in">dir</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">git <span class="built_in">rm</span> [file] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">git <span class="built_in">rm</span> --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">git <span class="built_in">mv</span> [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><blockquote><p>把文件名 file1 添加到 .gitignore 文件里，Git 会停止跟踪 file1 的状态。</p></blockquote><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">git branch -a </span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [new branch] [remote branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">git checkout [branch name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">git merge [branch name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个 commit，合并进当前分支</span></span><br><span class="line">git cherry-pick [commit <span class="built_in">id</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地分支，-d 参数强制删除分支</span></span><br><span class="line">git branch -d [branch name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push [remote name]:[remote branch name]</span><br></pre></td></tr></table></figure><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区与暂存区的变化直接到仓库区</span></span><br><span class="line">git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有 diff 信息</span></span><br><span class="line">git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区修改到仓库区，合并到上次修改，并修改上次的提交信息</span></span><br><span class="line">git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">git push [remote name] [remote branch name]</span><br></pre></td></tr></table></figure><h2 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动 </span></span><br><span class="line">git fetch [remote name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息 </span></span><br><span class="line">git remote show [remote name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">git remote add [remote name] [remote url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">git pull [remote name] [remote branch name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支变基合并</span></span><br><span class="line">git pull --rebase [remote name] [remote branch name]</span><br></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区当前目录的所有文件到工作区</span></span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复工作区到指定 commit</span></span><br><span class="line">git checkout [commit <span class="built_in">id</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变</span></span><br><span class="line">git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次 commit 保持一致</span></span><br><span class="line">git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">git reset --hard [commit <span class="built_in">id</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个 commit，用于撤销指定 commit</span></span><br><span class="line">git revert [commit <span class="built_in">id</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将未提交的变化放在储藏区</span></span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将储藏区的内容恢复到当前工作区</span></span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看工作区文件修改状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看工作区文件修改具体内容</span></span><br><span class="line">git diff [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看暂存区文件修改内容</span></span><br><span class="line">git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本库修改记录</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某人提交记录</span></span><br><span class="line">git <span class="built_in">log</span> --author=someone</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个文件的历史具体修改内容</span></span><br><span class="line">git <span class="built_in">log</span> -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某次提交具体修改内容</span></span><br><span class="line">git show [commit <span class="built_in">id</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解序列化和反序列化</title>
      <link href="/posts/27710.html"/>
      <url>/posts/27710.html</url>
      
        <content type="html"><![CDATA[<h2 id="序列化是干啥用的？"><a href="#序列化是干啥用的？" class="headerlink" title="序列化是干啥用的？"></a>序列化是干啥用的？</h2><p>序列化的原本意图是希望对一个Java对象作一下“变换”，变成字节序列，这样一来方便持久化存储到磁盘，避免程序运行结束后对象就从内存里消失，另外变换成字节序列也更便于网络运输和传播，所以概念上很好理解：</p><ul><li><strong>序列化</strong>：把Java对象转换为字节序列</li><li><strong>反序列化</strong>：把字节序列恢复为原先的Java对象</li></ul> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027095921086.png" alt="image-20231027095921086" style="zoom:67%;" /><p>而且序列化机制从某种意义上来说也弥补了平台化的一些差异，毕竟转换后的字节流可以在其他平台上进行反序列化来恢复对象。</p><h2 id="对象如何序列化？"><a href="#对象如何序列化？" class="headerlink" title="对象如何序列化？"></a>对象如何序列化？</h2><p>然而Java目前并没有一个关键字可以直接去定义一个所谓的“可持久化”对象。</p><p>对象的持久化和反持久化需要靠程序员在代码里手动<strong>显式地</strong>进行序列化和反序列化还原的动作。</p><p>举个例子，假如我们要对<code>Student</code>类对象序列化到一个名为<code>student.txt</code>的文本文件中，然后再通过文本文件反序列化成<code>Student</code>类对象：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027100014499.png" alt="image-20231027100014499" style="zoom: 67%;" /><ol><li><code>Stuent</code>类的定义</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student:&quot;</span> + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;name = &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;age = &quot;</span> + <span class="built_in">this</span>.age + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;score = &quot;</span> + <span class="built_in">this</span>.score + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>序列化方法：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(  )</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.setName(<span class="string">&quot;CodeSheep&quot;</span>);</span><br><span class="line">    student.setAge( <span class="number">18</span> );</span><br><span class="line">    student.setScore( <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>( <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>( <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;student.txt&quot;</span>) ) );</span><br><span class="line">    objectOutputStream.writeObject( student );</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;序列化成功！已经生成student.txt文件&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;==============================================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>反序列化方法：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deserialize</span><span class="params">(  )</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>( <span class="keyword">new</span> <span class="title class_">FileInputStream</span>( <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;student.txt&quot;</span>) ) );</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;反序列化结果为：&quot;</span>);</span><br><span class="line">    System.out.println( student );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>运行结果</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">序列化成功！已经生成student.txt文件</span><br><span class="line">==============================================</span><br><span class="line">反序列化结果为：</span><br><span class="line">Student:</span><br><span class="line">name = CodeSheep</span><br><span class="line">age = 18</span><br><span class="line">score = 1000</span><br></pre></td></tr></table></figure><h2 id="Serializable接口有何用？"><a href="#Serializable接口有何用？" class="headerlink" title="Serializable接口有何用？"></a>Serializable接口有何用？</h2><p>上面在定义<code>Student</code>类时，实现了一个<code>Serializable</code>接口，然而当我们点进<code>Serializable</code>接口内部查看，发现它<strong>竟然是一个空接口</strong>，并没有包含任何方法！</p><p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027100820022.png" alt="image-20231027100820022"></p><p>试想，如果上面在定义<code>Student</code>类时忘了加<code>implements Serializable</code>时会发生什么呢？</p><p>实验结果是：此时的程序运行<strong>会报错</strong>，并抛出<code>NotSerializableException</code>异常：</p><p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027100513021.png" alt="image-20231027100513021"></p><p>我们按照错误提示，由源码一直跟到<code>ObjectOutputStream</code>的<code>writeObject0()</code>方法底层一看，才恍然大悟：</p><p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027100552576.png" alt="image-20231027100552576"></p><p>如果一个对象既不是<strong>字符串</strong>、<strong>数组</strong>、<strong>枚举</strong>，而且也没有实现<code>Serializable</code>接口的话，在序列化时就会抛出<code>NotSerializableException</code>异常！</p><p>所以，我们明白了！原来<code>Serializable</code>接口也仅仅只是做一个标记用！</p><p>它告诉代码只要是实现了<code>Serializable</code>接口的类都是可以被序列化的！然而真正的序列化动作不需要靠它完成。</p><h2 id="serialVersionUID有何用？"><a href="#serialVersionUID有何用？" class="headerlink" title="serialVersionUID有何用？"></a>serialVersionUID有何用？</h2><p>相信你一定经常看到有些类中定义了如下代码行，即定义了一个名为<code>serialVersionUID</code>的字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">4392658638228508589L</span>;</span><br></pre></td></tr></table></figure><p><strong>你知道这句声明的含义吗？为什么要搞一个名为<code>serialVersionUID</code>的序列号？</strong></p><p>继续来做一个简单实验，还拿上面的<code>Student</code>类为例，我们并没有人为在里面显式地声明一个<code>serialVersionUID</code>字段。</p><p>我们首先还是调用上面的<code>serialize()</code>方法，将一个<code>Student</code>对象序列化到本地磁盘上的<code>student.txt</code>文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.setName(<span class="string">&quot;CodeSheep&quot;</span>);</span><br><span class="line">    student.setAge( <span class="number">18</span> );</span><br><span class="line">    student.setScore( <span class="number">100</span> );</span><br><span class="line"></span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>( <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>( <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;student.txt&quot;</span>) ) );</span><br><span class="line">    objectOutputStream.writeObject( student );</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们在<code>Student</code>类里面动点手脚，比如在里面再增加一个名为<code>studentID</code>的字段，表示学生学号：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027100934220.png" alt="image-20231027100934220" style="zoom:67%;" /><p>这时候，我们拿刚才已经序列化到本地的<code>student.txt</code>文件，还用如下代码进行反序列化，试图还原出刚才那个<code>Student</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deserialize</span><span class="params">(  )</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>( <span class="keyword">new</span> <span class="title class_">FileInputStream</span>( <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;student.txt&quot;</span>) ) );</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;反序列化结果为：&quot;</span>);</span><br><span class="line">    System.out.println( student );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行发现<strong>报错了</strong>，并且抛出了<code>InvalidClassException</code>异常：</p><p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027101017797.png" alt="image-20231027101017797"></p><p>这地方提示的信息非常明确了：序列化前后的<code>serialVersionUID</code>号码不兼容！</p><p>从这地方最起码可以得出两个重要信息：</p><ol><li><strong>serialVersionUID是序列化前后的唯一标识符</strong></li><li><strong>默认如果没有人为显式定义过<code>serialVersionUID</code>，那编译器会为它自动声明一个</strong></li></ol><p><code>serialVersionUID</code>序列化ID，可以看成是序列化和反序列化过程中的“暗号”，在反序列化时，JVM会把字节流中的序列号ID和被序列化类中的序列号ID做比对，只有两者一致，才能重新反序列化，否则就会报异常来终止反序列化的过程。</p><p>如果在定义一个可序列化的类时，没有人为显式地给它定义一个<code>serialVersionUID</code>的话，则Java运行时环境会根据该类的各方面信息自动地为它生成一个默认的<code>serialVersionUID</code>，一旦像上面一样更改了类的结构或者信息，则类的<code>serialVersionUID</code>也会跟着变化。</p><p>所以，为了<code>serialVersionUID</code>的确定性，写代码时还是建议，凡是<code>implements Serializable</code>的类，都最好人为显式地为它声明一个<code>serialVersionUID</code>明确值。</p><p>当然，如果不想手动赋值，你也可以借助IDE的自动添加功能，比如我使用的<code>IntelliJ IDEA</code>，按<code>alt + enter</code>就可以为类自动生成和添加<code>serialVersionUID</code>字段，十分方便：</p><p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027101259093.png" alt="image-20231027101259093"></p><h2 id="两种特殊情况"><a href="#两种特殊情况" class="headerlink" title="两种特殊情况"></a>两种特殊情况</h2><ol><li>凡是被<code>static</code>修饰的字段是不会被序列化的</li><li>凡是被<code>transient</code>修饰符修饰的字段也是不会被序列化的</li></ol><p>对于第一点，因为序列化保存的是<strong>对象的状态</strong>而非类的状态，所以会忽略<code>static</code>静态域也是理所应当的。</p><p>对于第二点，就需要了解一下<code>transient</code>修饰符的作用了。</p><p>如果在序列化某个类的对象时，就是不希望某个字段被序列化（比如这个字段存放的是隐私值，如：<code>密码</code>等），那这时就可以用<code>transient</code>修饰符来修饰该字段。</p><p>比如在之前定义的<code>Student</code>类中，加入一个<strong>密码字段</strong>，但是不希望序列化到<code>txt</code>文本，则可以：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027101556356.png" alt="image-20231027101556356" style="zoom:80%;" /><p>这样在序列化<code>Student</code>类对象时，<code>password</code>字段会设置为默认值<code>null</code>，这一点可以从反序列化所得到的结果来看出：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027101622542.png" alt="image-20231027101622542" style="zoom:80%;" /><h2 id="序列化的受控和加强"><a href="#序列化的受控和加强" class="headerlink" title="序列化的受控和加强"></a>序列化的受控和加强</h2><h3 id="约束性加持"><a href="#约束性加持" class="headerlink" title="约束性加持"></a>约束性加持</h3><p>从上面的过程可以看出，序列化和反序列化的过程其实是<strong>有漏洞的</strong>，因为从序列化到反序列化是有中间过程的，如果被别人拿到了中间字节流，然后加以伪造或者篡改，那反序列化出来的对象就会有一定风险了。</p><p>毕竟反序列化也相当于一种 <strong>“隐式的”对象构造</strong> ，因此我们希望在反序列化时，进行<strong>受控的</strong>对象反序列化动作。</p><p>那怎么个受控法呢？</p><p>答案就是： 自行编写<code>readObject()</code>函数，用于对象的反序列化构造，从而提供约束性。</p><p>既然自行编写<code>readObject()</code>函数，那就可以做很多可控的事情：比如各种判断工作。</p><p>还以上面的<code>Student</code>类为例，一般来说学生的成绩应该在<code>0 ~ 100</code>之间，我们为了防止学生的考试成绩在反序列化时被别人篡改成一个奇葩值，我们可以自行编写<code>readObject()</code>函数用于反序列化的控制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">( ObjectInputStream objectInputStream )</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用默认的反序列化函数</span></span><br><span class="line">    objectInputStream.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手工检查反序列化后学生成绩的有效性，若发现有问题，即终止操作！</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="number">0</span> &gt; score || <span class="number">100</span> &lt; score ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;学生分数只能在0到100之间！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我故意将学生的分数改为<code>101</code>，此时反序列化立马终止并且报错：</p><p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027101821197.png" alt="image-20231027101821197"></p><p>对于上面的代码，有些小伙伴可能会好奇，为什么自定义的<code>private</code>的<code>readObject()</code>方法可以被自动调用，这就需要你跟一下底层源码来一探究竟了，我们跟到<code>ObjectStreamClass</code>类的最底层，看到这里我相信你一定恍然大悟：</p><p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027101914134.png" alt="image-20231027101914134"></p><p>又是反射机制在起作用！是的，在Java里，果然万物皆可“反射”，即使是类中定义的<code>private</code>私有方法，也能被抠出来执行了，简直引起舒适了。</p><h3 id="单例模式增强"><a href="#单例模式增强" class="headerlink" title="单例模式增强"></a>单例模式增强</h3><p>一个容易被忽略的问题是：<strong>可序列化的单例类有可能并不单例</strong>！</p><p>比如这里我们先写一个常见的「静态内部类」方式的单例模式实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">1576643344804979563L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写一个main方法测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>( <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;singleton.txt&quot;</span>) )</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 将单例对象先序列化到文本文件singleton.txt中</span></span><br><span class="line">        objectOutputStream.writeObject( Singleton.getSingleton() );</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">FileInputStream</span>( <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;singleton.txt&quot;</span>) )</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 将文本文件singleton.txt中的对象反序列化为singleton1</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton1</span> <span class="operator">=</span> (Singleton) objectInputStream.readObject();</span><br><span class="line">        objectInputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton2</span> <span class="operator">=</span> Singleton.getSingleton();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行结果竟打印 false ！</span></span><br><span class="line">        System.out.println( singleton1 == singleton2 );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后我们发现：<strong>反序列化后的单例对象和原单例对象并不相等</strong>了，这无疑没有达到我们的目标。</p><p><strong>解决办法是</strong>：在单例类中手写<code>readResolve()</code>函数，直接返回单例对象，来规避之：</p><p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027102357121.png" alt="image-20231027102357121"></p><p>这样一来，当反序列化从流中读取对象时，<code>readResolve()</code>会被调用，用其中返回的对象替代反序列化新建的对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>float和double的坑</title>
      <link href="/posts/43863.html"/>
      <url>/posts/43863.html</url>
      
        <content type="html"><![CDATA[<h2 id="先看现象"><a href="#先看现象" class="headerlink" title="先看现象"></a>先看现象</h2><p>涉及诸如<code>float</code>或者<code>double</code>这两种浮点型数据的处理时，偶尔总会有一些<strong>怪怪的现象</strong>，不知道大家注意过没，举几个常见的栗子：</p><p><strong>典型现象一：条件判断超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println( <span class="number">1f</span> == <span class="number">0.9999999f</span> );   <span class="comment">// 打印：false</span></span><br><span class="line">System.out.println( <span class="number">1f</span> == <span class="number">0.99999999f</span> );  <span class="comment">// 打印：true    纳尼？</span></span><br></pre></td></tr></table></figure><p><strong>典型现象二：数据转换超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1f</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> (<span class="type">double</span>) f;</span><br><span class="line">System.out.println(f);  <span class="comment">// 打印：1.1</span></span><br><span class="line">System.out.println(d);  <span class="comment">// 打印：1.100000023841858  纳尼？</span></span><br></pre></td></tr></table></figure><p><strong>典型现象三：基本运算超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println( <span class="number">0.2</span> + <span class="number">0.7</span> );  <span class="comment">// 打印：0.8999999999999999   纳尼？</span></span><br></pre></td></tr></table></figure><p><strong>典型现象四：数据自增超预期</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">8455263f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(f1);</span><br><span class="line">    f1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印：8455263.0</span></span><br><span class="line"><span class="comment">// 打印：8455264.0</span></span><br><span class="line"><span class="comment">// 打印：8455265.0</span></span><br><span class="line"><span class="comment">// 打印：8455266.0</span></span><br><span class="line"><span class="comment">// 打印：8455267.0</span></span><br><span class="line"><span class="comment">// 打印：8455268.0</span></span><br><span class="line"><span class="comment">// 打印：8455269.0</span></span><br><span class="line"><span class="comment">// 打印：8455270.0</span></span><br><span class="line"><span class="comment">// 打印：8455271.0</span></span><br><span class="line"><span class="comment">// 打印：8455272.0</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">84552631f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(f2);</span><br><span class="line">    f2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br><span class="line"><span class="comment">//    打印：8.4552632E7   纳尼？不是 +1了吗？</span></span><br></pre></td></tr></table></figure><p>看到没，这些简单场景下的使用情况都很难满足我们的需求，所以说用浮点数（包括<code>double</code>和<code>float</code>）处理问题有非常多<strong>隐晦的坑</strong>在等着咱们！</p><p>所以我们在处理诸如 <strong>商品金额</strong>、<strong>订单交易</strong>、以及<strong>货币计算</strong>时，是万万不敢使用<code>float</code>和<code>double</code>类型的。</p><h2 id="原因出在哪里？"><a href="#原因出在哪里？" class="headerlink" title="原因出在哪里？"></a>原因出在哪里？</h2><p>我们就以第一个典型现象为例来分析一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println( <span class="number">1f</span> == <span class="number">0.99999999f</span> );</span><br></pre></td></tr></table></figure><p>直接用代码去比较<code>1</code>和<code>0.99999999</code>，居然打印出<code>true</code>！</p><p>这说明了什么？这说明了计算机压根<strong>区分不出来</strong>这两个数。这是为什么呢？</p><p>我们不妨来简单思考一下：</p><p>我们知道输入的这两个浮点数只是我们人类肉眼所看到的具体数值，是我们通常所理解的十进制数，但是计算机底层在计算时可不是按照十进制来计算的，学过基本计组原理的都知道，计算机底层最终都是基于像<code>010100100100110011011</code>这种<code>0</code>、<code>1</code>二进制来完成的。</p><p>所以为了搞懂实际情况，我们应该将这两个十进制浮点数<strong>转化到二进制</strong>来看一看。</p><p><strong>十进制浮点数转二进制</strong> 怎么转、怎么计算，我想这应该属于基础计算机进制转换常识，在 <strong>《计算机组成原理》</strong> 类似的课上肯定学过了，咱就不在此赘述了，直接给出结果（把它转换到<code>IEEE 754 Single precision 32-bit</code>，也就<code>float</code>类型对应的精度）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.0（十进制）</span><br><span class="line">    ↓</span><br><span class="line">00111111 10000000 00000000 00000000（二进制）</span><br><span class="line">    ↓</span><br><span class="line">0x3F800000（十六进制）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0.99999999（十进制）</span><br><span class="line">    ↓</span><br><span class="line">00111111 10000000 00000000 00000000（二进制）</span><br><span class="line">    ↓</span><br><span class="line">0x3F800000（十六进制）</span><br></pre></td></tr></table></figure><p><strong>果不其然</strong>，这两个十进制浮点数的底层二进制表示是一毛一样的，怪不得<code>==</code>的判断结果返回<code>true</code>！</p><p>但是<code>1f == 0.9999999f</code>返回的结果是符合预期的，打印<code>false</code>，我们也把它们转换到二进制模式下看看情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.0（十进制）</span><br><span class="line">    ↓</span><br><span class="line">00111111 10000000 00000000 00000000（二进制）</span><br><span class="line">    ↓</span><br><span class="line">0x3F800000（十六进制）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0.9999999（十进制）</span><br><span class="line">    ↓</span><br><span class="line">00111111 01111111 11111111 11111110（二进制）</span><br><span class="line">    ↓</span><br><span class="line">0x3F7FFFFE（十六进制）</span><br></pre></td></tr></table></figure><p>很明显，它俩的二进制数字表示确实不一样，这是理所应当的结果。</p><p>那么为什么<code>0.99999999</code>的底层二进制表示竟然是：<code>00111111 10000000 00000000 00000000</code>呢？</p><p>这不明明是浮点数<code>1.0</code>的二进制表示吗？</p><p>这就要谈一下浮点数的精度问题了。</p><h2 id="浮点数精度"><a href="#浮点数精度" class="headerlink" title="浮点数精度"></a>浮点数精度</h2><p>学过 <strong>《计算机组成原理》</strong> 这门课的小伙伴应该都知道，浮点数在计算机中的存储方式遵循<strong>IEEE 754 浮点数计数标准</strong>，可以用科学计数法表示为</p><p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027092922860.png" alt="image-20231027092922860"></p><p>只要给出：<strong>符号（S）</strong>、<strong>阶码部分（E）</strong>、<strong>尾数部分（M）</strong> 这三个维度的信息，一个浮点数的表示就完全确定下来了，所以<code>float</code>和<code>double</code>这两种浮点数在内存中的存储结构如下所示：</p><p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027093014266.png" alt="image-20231027093014266"></p><p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027093037876.png" alt="image-20231027093037876"></p><ol><li><p><strong>符号部分（S）</strong></p><p><code>0</code>-正 <code>1</code>-负</p></li><li><p><strong>阶码部分（E）（指数部分）</strong></p><ul><li>对于<code>float</code>型浮点数，指数部分<code>8</code>位，考虑可正可负，因此可以表示的指数范围为<code>-127 ~ 128</code></li><li>对于<code>double</code>型浮点数，指数部分<code>11</code>位，考虑可正可负，因此可以表示的指数范围为<code>-1023 ~ 1024</code></li></ul></li><li><p><strong>尾数部分（M）</strong></p><p>浮点数的精度是由尾数的位数来决定的。</p><ul><li>对于<code>float</code>型浮点数，尾数部分<code>23</code>位，换算成十进制就是 <code>2^23=8388608</code>，所以十进制精度只有<code>6 ~ 7</code>位；</li><li>对于<code>double</code>型浮点数，尾数部分<code>52</code>位，换算成十进制就是 <code>2^52 = 4503599627370496</code>，所以十进制精度只有<code>15 ~ 16</code>位</li></ul></li></ol><p>所以对于上面的数值<code>0.99999999f</code>，很明显已经超过了<code>float</code>型浮点数据的精度范围，出问题也是在所难免的。</p><h2 id="精度问题如何解决？"><a href="#精度问题如何解决？" class="headerlink" title="精度问题如何解决？"></a>精度问题如何解决？</h2><p>所以如果涉及<strong>商品金额</strong>、<strong>交易值</strong>、<strong>货币计算</strong>等这种对精度要求很高的场景该怎么办呢？</p><p><strong>方法一：用字符串或者数组解决多位数问题</strong></p><p>校招刷过算法题的小伙伴们应该都知道，用字符串或者数组表示大数是一个典型的解题思路。</p><p>比如经典面试题：<strong>编写两个任意位数大数的加法、减法、乘法等运算</strong>。</p><p>这时候我们我们可以用字符串或者数组来表示这种大数，然后按照四则运算的规则来手动模拟出具体计算过程，中间还需要考虑各种诸如：<strong>进位</strong>、<strong>借位</strong>、<strong>符号</strong>等等问题的处理，确实十分复杂，本文不做赘述。</p><p><strong>方法二：Java的大数类是个好东西</strong></p><p>JDK早已为我们考虑到了浮点数的计算精度问题，因此提供了专用于高精度数值计算的<strong>大数类</strong>来方便我们使用。</p><p>Java的大数类位于<code>java.math</code>包下：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027093516586.png" alt="image-20231027093516586" style="zoom: 50%;" /><p>可以看到，常用的<code>BigInteger</code> 和 <code>BigDecimal</code>就是处理高精度数值计算的利器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>( Double.toString( <span class="number">1.0f</span> ) );</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>( Double.toString( <span class="number">0.99999999f</span> ) );</span><br><span class="line">System.out.println( num3 == num4 );  <span class="comment">// 打印 false</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>( Double.toString( <span class="number">0.2</span> ) );</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>( Double.toString( <span class="number">0.7</span> ) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加</span></span><br><span class="line">System.out.println( num1.add( num2 ) );  <span class="comment">// 打印：0.9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 减</span></span><br><span class="line">System.out.println( num2.subtract( num1 ) );  <span class="comment">// 打印：0.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘</span></span><br><span class="line">System.out.println( num1.multiply( num2 ) );  <span class="comment">// 打印：0.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除</span></span><br><span class="line">System.out.println( num2.divide( num1 ) );  <span class="comment">// 打印：3.5</span></span><br></pre></td></tr></table></figure><p>当然了，像<code>BigInteger</code> 和 <code>BigDecimal</code>这种大数类的运算效率肯定是不如原生类型效率高，代价还是比较昂贵的，是否选用需要根据实际场景来评估。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git和SVN对比</title>
      <link href="/posts/18649.html"/>
      <url>/posts/18649.html</url>
      
        <content type="html"><![CDATA[<h2 id="Git-vs-SVN"><a href="#Git-vs-SVN" class="headerlink" title="Git vs SVN"></a>Git vs SVN</h2><p><strong>一、Git是分布式的，SVN是集中式的</strong></p><p>这是Git和SVN最大的区别。若能掌握这个概念，两者区别基本搞懂大半。因为Git是分布式的，所以Git支持离线工作，在本地可以进行很多操作，而SVN必须联网才能正常工作。</p><p><strong>二、Git复杂概念多，SVN简单易上手</strong></p><p>所有同时掌握Git和SVN的开发者都必须承认，Git的命令实在太多了，日常工作需要掌握<code>add</code>,<code>commit</code>,<code>status</code>,<code>fetch</code>,<code>push</code>,<code>rebase</code>等，若要熟练掌握，还必须掌握<code>rebase</code>和<code>merge</code>的区别，<code>fetch</code>和<code>pull</code>的区别等，除此之外，还有<code>cherry-pick</code>，<code>submodule</code>，<code>stash</code>等功能，仅是这些名词听着都很绕。</p><p>在易用性这方面，SVN会好得多，简单易上手，对新手很友好。但是从另外一方面看，Git命令多意味着功能多，若我们能掌握大部分Git的功能，体会到其中的奥妙，会发现再也回不去SVN的时代了。</p><p><strong>三、Git分支廉价，SVN分支昂贵</strong></p><p>在版本管理里，分支是很常使用的功能。在发布版本前，需要发布分支，进行大需求开发，需要feature分支，大团队还会有开发分支，稳定分支等。在大团队开发过程中，常常存在创建分支，切换分支的需求。</p><p>Git分支是指针指向某次提交，而SVN分支是拷贝的目录。这个特性使Git的分支切换非常迅速，且创建成本非常低。</p><p>而且Git有本地分支，SVN无本地分支。在实际开发过程中，经常会遇到有些代码没写完，但是需紧急处理其他问题，若我们使用Git，便可以创建本地分支存储没写完的代码，待问题处理完后，再回到本地分支继续完成代码。</p><h2 id="Git核心思想"><a href="#Git核心思想" class="headerlink" title="Git核心思想"></a>Git核心思想</h2><p>Git最核心的概念如下：</p><ul><li><strong>工作区(Workspace)</strong> 是电脑中实际的目录。</li><li><strong>暂存区(Index)</strong> 类似于缓存区域，临时保存你的改动。</li><li>**仓库区(Repository)**，分为本地仓库和远程仓库。</li></ul><p>从SVN切换到Git，最难理解并且最不能理解的是暂存区和本地仓库。熟练使用Git后，会发现这简直是神设计，由于这两者的存在，使许多工作变得易管理。</p><p>通常提交代码分为几步：</p><ul><li><code>git add</code> ：从工作区提交到暂存区</li><li><code>git commit</code> ：从暂存区提交到本地仓库</li><li><code>git push</code> 或 <code>git svn dcommit</code>： 从本地仓库提交到远程仓库</li></ul><p>一般来说，记住以下命令，便可进行日常工作了：</p><p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231026124843144.png" alt="image-20231026124843144"></p><h2 id="Git-SVN"><a href="#Git-SVN" class="headerlink" title="Git-SVN"></a>Git-SVN</h2><p>看到Git-SVN不要懵！是的，在Git中甚至有命令可以直接和SVN进行桥接，Git中所有与SVN桥接的基础命令就是 <code>git svn</code></p><p>若服务器使用的SVN，但是本地想要体验Git的本地分支，离线操作等功能，可以使用Git-SVN功能。</p><p>常用操作如下：</p><p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231026125113817.png" alt="image-20231026125113817"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载一个 SVN 项目和它的整个代码历史，并初始化为 Git 代码库</span></span><br><span class="line">git svn <span class="built_in">clone</span> -s [repository]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前版本库情况</span></span><br><span class="line">git svn info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库所有分支的变化</span></span><br><span class="line">git svn fetch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库当前分支的变化，并与本地分支变基合并</span></span><br><span class="line">git svn rebase</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传当前分支的本地仓库到远程仓库</span></span><br><span class="line">git svn dcommit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取新分支，并提交到远程仓库</span></span><br><span class="line">svn copy [remote branch] [new remote branch] -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建远程分支对应的本地分支</span></span><br><span class="line">git checkout -b [<span class="built_in">local</span> branch] [remote branch]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>熟悉的陌生类-Object</title>
      <link href="/posts/45969.html"/>
      <url>/posts/45969.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Object是java所有类的基类，是整个类继承结构的顶端，也是最抽象的一个类</strong>。大家天天都在使用<code>toString()、equals()、hashCode()、wait()、notify()、getClass()</code>等方法，或许都没有意识到是<code>Object</code>类的方法，也没有去看<code>Object</code>类中还有哪些方法以及思考为什么这些方法要放到 <code>Object</code>中。本篇就每个方法具体功能、重写规则以及自己的一些理解。</p><h2 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h2><p><code>Object</code>中含有：<code>registerNatives()、getClass()、hashCode()、equals()、clone()、toString()、notify()、notifyAll()、wait(long)、wait(long,int)、wait()、finalize()</code> 共<strong>十二个方法</strong>。这个顺序是按照<code>Object</code>类中定义方法的顺序列举的，下面我也会按照这个顺序依次进行讲解。</p><h3 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives()"></a>registerNatives()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从名字上理解，这个方法是注册<code>native</code>方法</strong>（本地方法，由<code>JVM</code>实现，底层是<code>C/C++</code>实现的）**向谁注册呢？当然是向<code>JVM</code>**，当有程序调用到<code>native</code>方法时， <code>JVM</code>才好去找到这些底层的方法进行调用。</p><blockquote><p><code>Object</code>中的<code>native</code>方法，以及使用<code>registerNatives()</code>向<code>JVM</code>进行注册相关的知识属于<code>JNI</code>的范畴，有兴趣的可自行查阅。</p></blockquote><p><strong>为什么要使用静态方法，还要放到静态块中呢？</strong></p><p>我们知道在类初始化的时候，会依次将从父类到本类的类变量及类初始化块中的类变量及方法按照定义顺序放到<code>&lt;clinit&gt;</code>方法中，这样可以保证父类的类变量及方法的初始化一定先于子类。所以当子类调用相应<code>native</code>方法，比如计算<code>hashCode</code>时，一定可以保证能够调用到<code>JVM</code>的 <code>native</code>方法。</p><h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure><p>这是一个<code>public</code>的方法，我们可以直接通过对象调用。</p><p>类加载的第一阶段类的加载就是将<code>.class</code>文件加载到内存，并生成一个<code>java.lang.Class</code>对象的过程。 <code>getClass()</code>方法就是获取这个对象，这是当前类的对象在运行时类的所有信息的集合。这个方法是反射三种方式之一。</p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>这是一个<code>public</code>的方法，所以子类可以重写它。这个方法返回当前对象的<code>hashCode</code>值，这个值是一个整数范围内的 <code>（-2^31~2^31-1）</code>数字。</p><p>对于 <code>hashCode</code>有以下几点约束:</p><ol><li>在Java应用程序执行期间，在对同一对象多次调用<code>hashCode</code> 方法时，必须一致地返回相同的整数，前提是将对象进行<code>equals</code>比较时所用的信息没有被修改；</li><li>如果两个对象<code>x.equals(y)</code>方法返回<code>true</code>，则 <code>x</code>、<code>y</code>这两个对象的<code>hashCode</code>必须相等;</li><li>如果两个对象<code>x.equals(y)</code>方法返回<code>false</code>，则<code>x</code>、 <code>y</code>这两个对象的<code>hashCode</code>可以相等也可以不等。但是，为不相等的对象生成不同整数结果可以提高哈希表的性能。</li><li>默认的<code>hashCode</code>是将内存地址转换为的<code>hash</code>值，重写过后就是自定义的计算方式；也可以通过<code>System.identityHashCode(Object)</code>来返回原本的 <code>hashCode</code>。</li></ol><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于比较当前对象与目标对象是否相等，默认是比较引用是否指向同一对象。为<code>public</code>方法，子类可重写。</p><p><strong>为什么需要重写<code>equals</code>方法？</strong></p><p><strong>因为如果不重写equals方法，当将自定义对象放到<code>map</code>或者<code>set</code>中时</strong>；如果这时两个对象的 <code>hashCode</code>相同，就会调用 <code>equals</code>方法进行比较，这个时候会调用 <code>Object</code>中默认的<code>equals</code>方法，而默认的<code>equals</code>方法只是比较了两个对象的引用是否指向了同一个对象，显然大多数时候都不会指向，这样就会将重复对象存入<code>map</code>或者<code>set</code>中。这就<strong>破坏了<code>map</code>与<code>set</code>不能存储重复对象的特性，会造成内存溢出</strong>。</p><p><strong>重写<code>equals</code>方法的几条约定：</strong></p><ol><li><strong>自反性</strong>：即 <code>x.equals(x)</code>返回 <code>true</code>， <code>x</code>不为 <code>null</code>；</li><li><strong>对称性</strong>：即 <code>x.equals(y)</code>与 <code>y.equals(x）</code>的结果相同， <code>x</code>与 <code>y</code>不为 <code>null</code>；</li><li><strong>传递性</strong>：即 <code>x.equals(y)</code>结果为 <code>true</code>, <code>y.equals(z)</code>结果为 <code>true</code>，则 <code>x.equals(z)</code>结果也必须为 <code>true</code>；</li><li><strong>一致性</strong>：即 <code>x.equals(y)</code>返回 <code>true</code>或 <code>false</code>，在未更改 <code>equals</code>方法使用的参数条件下，多次调用返回的结果也必须一致。 <code>x</code>与 <code>y</code>不为 <code>null</code>;</li><li>如果<code>x</code>不为<code>null</code>,<code>x.equals(null)</code>返回<code>false</code>。</li></ol><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure><p>此方法返回当前对象的一个副本。</p><p>这是一个<code>protected</code>方法，提供给子类重写。但需要实现<code>Cloneable</code>接口，这是一个标记接口，如果没有实现，当调用<code>object.clone()</code>方法，会抛出 <code>CloneNotSupportedException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneTest</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略getter、setter方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> CloneTest <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneTest) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">CloneTest</span> <span class="variable">cloneTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneTest</span>(<span class="number">23</span>, <span class="string">&quot;XX&quot;</span>);</span><br><span class="line">        <span class="type">CloneTest</span> <span class="variable">clone</span> <span class="operator">=</span> cloneTest.clone();</span><br><span class="line">        System.out.println(clone == cloneTest);</span><br><span class="line">        System.out.println(cloneTest.getAge() == clone.getAge());</span><br><span class="line">        System.out.println(cloneTest.getName() == clone.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从输出我们看见，<code>clone</code>的对象是一个新的对象；但原对象与<code>clone</code>对象的<code>String</code>类型的<code>name</code>却是同一个引用，这表明，<code>super.clone</code>方法对成员变量如果是引用类型的，进行是浅拷贝。</p><p><strong>那如果我们要进行深拷贝怎么办呢？</strong> </p><p>答案是：如果成员变量是引用类型，想实现深拷贝，则成员变量也要实现<code>Cloneable</code>接口，重写<code>clone</code>方法。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个<code>public</code>方法，子类可重写，建议所有子类都重写 <code>toString</code>方法，默认的 <code>toString</code>方法，只是将当前类的全限定性类名 <code>+@+</code>十六进制的 <code>hashCode</code>值。</p><p>我们思考一下为什么需要toString方法？</p><p>可以这么理解：返回当前对象的字符串表示，可以将其打印方便查看对象的信息，方便记录日志信息提供调试。我们可以选择需要表示的重要信息重写到 <code>toString</code>方法中。</p><h3 id="wait-wait-long-wait-long-int"><a href="#wait-wait-long-wait-long-int" class="headerlink" title="wait()&#x2F;wait(long)&#x2F;wait(long,int)"></a>wait()&#x2F;wait(long)&#x2F;wait(long,int)</h3><p><code>wait()</code>方法还有两个带参数的重载方法： <code>wait(long)</code> 、 <code>wait(long,int)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                            <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个方法是用来线程间通信用的，作用是阻塞当前线程，等待其他线程调用<code>notify()/notifyAll()</code>方法将其唤醒。这些方法都是<code>public final</code>的，不可被重写。</p><p>注意：</p><ol><li>此方法只能在当前线程获取到对象的锁监视器之后才能调用，否则会抛出<code>IllegalMonitorStateException</code>异常。</li><li>调用<code>wait</code>方法，线程会将锁监视器进行释放；而<code>Thread.sleep，Thread.yield()</code>并不会释放锁。</li><li><code>wait</code>方法会一直阻塞，直到其他线程调用当前对象的 <code>notify()/notifyAll()</code>方法将其唤醒；而 <code>wait(long)</code>是等待给定超时时间内（单位毫秒），如果还没有调用<code>notify()/nofiyAll()</code>会自动唤醒；<code>wait(long,int)</code>如果第二个参数大于<code>0</code>并且小于<code>999999</code>，则第一个参数<code>+1</code>作为超时时间；</li></ol><h3 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify()&#x2F;notifyAll()"></a>notify()&#x2F;notifyAll()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>前面说了，如果当前线程获得了当前对象锁，调用<code>wait</code>方法，将锁释放并阻塞；这时另一个线程获取到了此对象锁，并调用此对象的 <code>notify()/notifyAll()</code>方法将之前的线程唤醒。这些方法都是<code>public final</code>的，不可被重写。</p><ol><li><code>public final native void notify();</code> 随机唤醒之前在当前对象上调用<code>wait</code>方法的一个线程;</li><li><code>public final native void notifyAll()</code>; 唤醒所有之前在当前对象上调用<code>wait</code>方法的线程</li></ol><p><strong>注意</strong>：调用<code>notify()</code>后，阻塞线程被唤醒，可以参与锁的竞争，但可能调用<code>notify()</code>方法的线程还要继续做其他事，锁并未释放，所以我们看到的结果是，无论<code>notify()</code>是在方法一开始调用，还是最后调用，阻塞线程都要等待当前线程结束才能开始。</p><p>为什么<code>wait()/notify()</code>方法要放到<code>Object</code>中呢？ </p><p>因为每个对象都可以成为锁监视器对象，所以放到<code>Object</code>中，可以直接使用。</p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><p>此方法是在垃圾回收之前，JVM会调用此方法来清理资源。此方法可能会将对象重新置为可达状态，导致JVM无法进行垃圾回收。</p><p>我们知道Java相对于C++很大的优势是程序员不用手动管理内存，内存由JVM管理；如果我们的引用对象在堆中没有引用指向他们时，当内存不足时，JVM会自动将这些对象进行回收释放内存，这就是我们常说的垃圾回收。但垃圾回收没有讲述的这么简单。</p><p><strong><code>finalize()</code>方法具有如下4个特点：</strong></p><ol><li>永远不要主动调用某个对象的<code>finalize()</code>方法，该方法由垃圾回收机制自己调用；</li><li><code>finalize()</code>何时被调用，是否被调用具有不确定性；</li><li>当<code>JVM</code>执行可恢复对象的 <code>finalize()</code>可能会将此对象重新变为可达状态；</li><li>当<code>JVM</code>执行<code>finalize()</code>方法时出现异常，垃圾回收机制不会报告异常，程序继续执行。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单谈谈锁</title>
      <link href="/posts/27218.html"/>
      <url>/posts/27218.html</url>
      
        <content type="html"><![CDATA[<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p>从各种不同角度出发，可以对Java中的锁进行分类，这些分类并不是互斥的，也就是多个类型可以并存，有可能一个锁同时属于两种类型，比如ReentrantLock既是互斥锁，又是可重入锁。</p><p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/20231003_1696305899723.jpg" alt="20231003_1696305899723.jpg"></p><h2 id="悲观锁VS乐观锁"><a href="#悲观锁VS乐观锁" class="headerlink" title="悲观锁VS乐观锁"></a>悲观锁VS乐观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>如果我不锁住这个资源，别人就会来争抢，就会造成数据结果错误，所以每次悲观锁为了确保结果的正确性，会在每次获取并修改数据时，把数据锁住，让别人无法访问该数据，这样就可以确保数据内容万无一失。</p><p>Java中悲观锁的实现就是synchronized和Lock相关类。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>认为自己在处理操作的时候不会有其他线程来干扰，所以并不会锁住被操作对象。在提交更新的时候，去对比在我修改的期间数据有没有被其他人改变过，如果没被改变过，就说明真的是只有我自己在操作，那我就正常去修改数据。</p><p>如果数据和我一开始拿到的不一样了，说明其他人在这段时间内改过数据，那我就不能继续刚才的更新数据过程了，我会选择报错、重试等策略。</p><p>乐观锁的实现一般都是利用CAS算法来实现的。</p><h3 id="开销对比"><a href="#开销对比" class="headerlink" title="开销对比"></a>开销对比</h3><p>悲观锁的原始开销要高于乐观锁，但是特点是一劳永逸，临界区持锁时间就算越来越差，也不会对互斥锁的开销造成影响。<br>相反，虽然乐观锁一开始的开销比悲观锁小，但是如果自旋时间很长或者不停重试，那么消耗的资源也会越来越多。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>悲观锁：适合并发写入多的情况，适用于临界区持锁时间比较长的情况，悲观锁可以避免大量的无用自旋等消耗，</p><p>典型情况:</p><ul><li>临界区有IO操作</li><li>临界区代码复杂或循环量大</li><li>临界区竞争非常激烈</li></ul><p>乐观锁：适合并发写入少，大部分是读取的场景，不加锁的能让读取性能大幅提高。</p><h2 id="公平锁VS非公平锁"><a href="#公平锁VS非公平锁" class="headerlink" title="公平锁VS非公平锁"></a>公平锁VS非公平锁</h2><p>公平指的是按照线程请求的顺序，来分配锁，非公平指的是不完全按照请求的顺序，在一定情况下，可以插队。</p><table><thead><tr><th></th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>公平锁</td><td>各线程公平平等，每个线程在等待一段时间后，总有执行的机会</td><td>更慢，吞吐量小</td></tr><tr><td>非公平锁</td><td>更快，吞吐量大</td><td>有可能产生线程饥饿，也就是某些线程长时间内始终得不到执行</td></tr></tbody></table><h2 id="共享锁VS排他锁"><a href="#共享锁VS排他锁" class="headerlink" title="共享锁VS排他锁"></a>共享锁VS排他锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>共享锁，又称为读锁，获得共享锁之后，可以查看但无法修改和删除数据，其他线程此时也可以获取到共享锁，也可以查看但无法修改和删除数据。</p><p>排他锁，又称为独占锁、独享锁。</p><p>共享锁和排它锁的典型是读写锁ReentrantReadWriteLock，其中读锁是共享锁，写锁是独享锁。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁的作用</p><p>在没有读写锁之前，我们假设使用ReentrantLock,那么虽然我们保证了线程安全，但是也浪费了一定的资源。多个读操作同时进行，并没有线程安全问题<br>在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的提高了程序的执行效率。</p><p>读写锁规则</p><ul><li>多个线程只申请读锁，都可以申请到。</li><li>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。</li><li>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</li><li>一句话总结：要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现（要么多读，要么一写）。</li></ul><p>换一种思路更容易理解：读写锁只是一把锁，可以通过两种方式锁定读锁定和写锁定。读写锁可以同时被一个或多个线程读锁定，也可以被单一线程写锁定。但是永远不能同时对这把锁进行读锁定和写锁定。</p><blockquote><p>这里是把“获取写锁”理解为“把读写锁进行写锁定”，相当于是换了一种思路，不过原则是不变的，就是要么是一个或多个线程同时有读锁（同时读锁定），要么是一个线程有写锁（进行写锁定），但是两者不会同时出现。</p></blockquote><h2 id="自旋锁VS阻塞锁"><a href="#自旋锁VS阻塞锁" class="headerlink" title="自旋锁VS阻塞锁"></a>自旋锁VS阻塞锁</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。</p><p>如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁，而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是<strong>自旋锁</strong>。</p><p>阻塞锁和自旋锁相反，阻塞锁如果遇到没拿到锁的情况，会直接把线程阻塞，直到被唤醒</p><p><strong>自旋锁的缺点</strong></p><p>如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。在自旋的过程中，一直消耗cpu，所以虽然自旋锁的起始开销低于悲观锁，但是随着自旋时间的增长，开销也是线性增长的。</p><p><strong>自旋锁的适用场景</strong></p><p>自旋锁一般用于多核的服务器，在并发度不是特别高的情况下，比阻塞锁的效率高。<br>另外，自旋锁适用于临界区比较短小的情况，否则如果临界区很大（线程一旦拿到锁，很久以后才会释放），不太合适。</p><h2 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h2><p>在Java中，synchronized就不是可中断锁，而lock是可中断锁，因为<code>tryLock(time)</code>和<code>lockInterruptibly</code>都能响应中断。</p><p>如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁可能由于等待时间过长，线程B不想等待了，想先处理其他事情我们可以中断它，这种就是可中断锁。</p><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>锁是一种工具，用于控制对共享资源的访问。<br>Lock和synchronized，这两个是最常见的锁，它们都可以达到线程安全的目的，但是在使用上和功能上又有较大的不同。Lock并不是用来代替synchronized的，而是当使用synchronized不合适或不足以满足要求的时候，来提供高级功能的。</p><h3 id="synchronized不足"><a href="#synchronized不足" class="headerlink" title="synchronized不足"></a>synchronized不足</h3><ul><li>效率低。锁的释放情况少、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程。</li><li>不够灵活。加锁和释放的时机单一，每个锁仅有单一的条件（某个对象)，可能是不够的。</li><li>无法知道是否成功获取到锁。</li></ul><h3 id="Lock获取锁方法"><a href="#Lock获取锁方法" class="headerlink" title="Lock获取锁方法"></a>Lock获取锁方法</h3><p>在Lock中声明了四个方法来获取锁：</p><ul><li>lock()</li><li>tryLock</li><li>tryLock(long time,TimeUnit unit)</li><li>lockInterruptibly()</li></ul><p>那么这四个方法有何区别呢？</p><p>lock()就是最普通的获取锁。如果锁已被其他线程获取，则进行等待; Lock不会像synchronized一样在异常时自动释放锁,因此最佳实践是，在finally中释放锁，以保证发生异常时锁一定被释放;lock()方法不能被中断，这会带来很大的隐患：一旦陷入死锁Iock()就会陷入永久等待。</p><p>tryLock()用来尝试获取锁，如果当前锁没有被其他线程占用则获取成功，则返回true,否则返回false，代表获取锁失败。相比于lock()，这样的方法显然功能更强大了，我们可以根据是否能获取到锁来决定后续程序的行为。该方法会立即返回，即便在拿不到锁时不会一直在那等。</p><p>tryLock(long time, TimeUnit unit)添加了超时时间。</p><p>lockInterruptibly()相当于tryLock(long time, TimeUnit unit)，把超时时间设置为无限。在等待锁的过程中，线程可以被中断。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝VS浅拷贝</title>
      <link href="/posts/49310.html"/>
      <url>/posts/49310.html</url>
      
        <content type="html"><![CDATA[<h2 id="值类型-vs-引用类型"><a href="#值类型-vs-引用类型" class="headerlink" title="值类型 vs 引用类型"></a>值类型 vs 引用类型</h2><p>这两个概念的准确区分，对于深、浅拷贝问题的理解非常重要。</p><p>正如<code>Java</code>圣经《<code>Java</code>编程思想》第二章的标题所言，在<code>Java</code>中一切都可以视为对象！</p><p>所以来到<code>Java</code>的世界，我们要习惯用引用去操作对象。在<code>Java</code>中，像数组、类<code>Class</code>、枚举<code>Enum</code>、<code>Integer</code>包装类等等，就是典型的引用类型，所以操作时一般来说采用的也是<strong>引用传递</strong>的方式。但是<code>Java</code>的语言级基础数据类型，诸如<code>int</code>这些基本类型，操作时一般采取的则是<strong>值传递</strong>的方式，所以有时候也称它为值类型。</p><p>为了便于下文的讲述和举例，我们这里先定义两个类：<code>Student</code>和<code>Major</code>，分别表示「学生」以及「所学的专业」，二者是包含关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学生的所学专业</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Major</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String majorName; <span class="comment">// 专业名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> majorId;     <span class="comment">// 专业代号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学生</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;      <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Major major;  <span class="comment">// 所学专业</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027135345680.png" alt="image-20231027135345680" style="zoom:67%;" /><h2 id="赋值-vs-浅拷贝-vs-深拷贝"><a href="#赋值-vs-浅拷贝-vs-深拷贝" class="headerlink" title="赋值 vs 浅拷贝 vs 深拷贝"></a>赋值 vs 浅拷贝 vs 深拷贝</h2><h3 id="对象赋值"><a href="#对象赋值" class="headerlink" title="对象赋值"></a>对象赋值</h3><p>赋值是日常编程过程中最常见的操作，最简单的比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> stu1;</span><br></pre></td></tr></table></figure><p>严格来说，这种不能算是对象拷贝，因为拷贝的仅仅只是引用关系，并没有生成新的实际对象：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027135815274.png" alt="image-20231027135815274" style="zoom:80%;" /><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝属于对象克隆方式的一种，重要的特性体现在这个<strong>「浅」</strong> 字上。</p><p>比如我们试图通过<code>studen1</code>实例，拷贝得到<code>student2</code>，如果是浅拷贝这种方式，大致模型可以示意成如下所示的样子：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027135944683.png" alt="image-20231027135944683" style="zoom:80%;" /><p>很明显，<strong>值类型</strong>的字段会复制一份，而<strong>引用类型</strong>的字段拷贝的仅仅是引用地址，而该引用地址指向的实际对象空间其实只有一份。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝相较于上面所示的浅拷贝，除了值类型字段会复制一份，引用类型字段所指向的对象，会在内存中也<strong>创建一个副本</strong>，就像这个样子：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027140125719.png" alt="image-20231027140125719" style="zoom: 80%;" /><p>原理很清楚明了，下面来看看具体的代码实现吧。</p><h3 id="浅拷贝实现代码"><a href="#浅拷贝实现代码" class="headerlink" title="浅拷贝实现代码"></a>浅拷贝实现代码</h3><p>还以上文的例子来讲，我想通过<code>student1</code>拷贝得到<code>student2</code>，浅拷贝的典型实现方式是：让被复制对象的类实现<code>Cloneable</code>接口，并重写<code>clone()</code>方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;      <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Major major;  <span class="comment">// 所学专业</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他省略 ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们写个测试代码，一试便知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Major</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Major</span>(<span class="string">&quot;计算机科学与技术&quot;</span>,<span class="number">666666</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>( <span class="string">&quot;Godfrey&quot;</span>, <span class="number">18</span>, m );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 由 student1 拷贝得到 student2</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> (Student) student1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println( student1 == student2 );</span><br><span class="line">        System.out.println( student1 );</span><br><span class="line">        System.out.println( student2 );</span><br><span class="line">        System.out.println( <span class="string">&quot;\n&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改student1的值类型字段</span></span><br><span class="line">        student1.setAge( <span class="number">35</span> );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改student1的引用类型字段</span></span><br><span class="line">        m.setMajorName( <span class="string">&quot;电子信息工程&quot;</span> );</span><br><span class="line">        m.setMajorId( <span class="number">888888</span> );</span><br><span class="line"></span><br><span class="line">        System.out.println( student1 );</span><br><span class="line">        System.out.println( student2 );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行得到如下结果：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027140635169.png" alt="image-20231027140635169" style="zoom:80%;" /><p>从结果可以看出：</p><ul><li><code>student1==student2</code>打印false，说明<code>clone()</code>方法的确克隆出了一个新对象；</li><li>修改值类型字段并不影响克隆出来的新对象，符合预期；</li><li>而修改了<code>student1</code>内部的引用对象，克隆对象<code>student2</code>也受到了波及，说明内部还是关联在一起的</li></ul><h3 id="深拷贝代码实现"><a href="#深拷贝代码实现" class="headerlink" title="深拷贝代码实现"></a>深拷贝代码实现</h3><p><strong>深度遍历式拷贝</strong></p><p>虽然<code>clone()</code>方法可以完成对象的拷贝工作，但是注意：<code>clone()</code>方法默认是浅拷贝行为，就像上面的例子一样。若想实现深拷贝需覆写 <code>clone()</code>方法实现引用对象的深度遍历式拷贝，进行地毯式搜索。</p><p>所以对于上面的例子，如果想实现深拷贝，首先需要对更深一层次的引用类<code>Major</code>做改造，让其也实现<code>Cloneable</code>接口并重写<code>clone()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Major</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次我们还需要在<strong>顶层的</strong>调用类中重写<code>clone</code>方法，来调用引用类型字段的<code>clone()</code>方法实现深度拷贝，对应到本文那就是<code>Student</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) <span class="built_in">super</span>.clone();</span><br><span class="line">        student.major = (Major) major.clone(); <span class="comment">// 重要！！！</span></span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候上面的测试用例不变，运行可得结果：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027143237618.png" alt="image-20231027143237618" style="zoom:80%;" /><p>很明显，这时候<code>student1</code>和<code>student2</code>两个对象就完全独立了，不受互相的干扰。</p><p><strong>利用反序列化实现深拷贝</strong></p><p>利用反序列化技术，我们也可以从一个对象深拷贝出另一个复制对象，而且这种方式在解决多层套娃式的深拷贝问题时效果出奇的好。</p><p>所以我们这里改造一下<code>Student</code>类，让其<code>clone()</code>方法通过序列化和反序列化的方式来生成一个原对象的深拷贝副本：·</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;      <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Major major;  <span class="comment">// 所学专业</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将对象本身序列化到字节流</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>( byteArrayOutputStream );</span><br><span class="line">            objectOutputStream.writeObject( <span class="built_in">this</span> );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 再将字节流通过反序列化方式得到对象副本</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>( <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>( byteArrayOutputStream.toByteArray() ) );</span><br><span class="line">            <span class="keyword">return</span> (Student) objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这种情况下要求被引用的子类（比如这里的<code>Major</code>类）也必须是可以序列化的，即实现了<code>Serializable</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Major</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... 其他省略 ...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候测试用例完全不变，直接运行，也可以得到如下结果：</p> <img src="https://guoze-oss.oss-cn-chengdu.aliyuncs.com/typro/image-20231027143619849.png" alt="image-20231027143619849" style="zoom:80%;" /><p>很明显，这时候<code>student1</code>和<code>student2</code>两个对象也是完全独立的，不受互相的干扰，深拷贝完成。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
